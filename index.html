<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
<title>åç‰‡æ‰«æåŠ©æ‰‹</title>
<style>
:root{--primary:#4f46e5;--primary-light:#eef2ff;--danger:#ef4444;--success:#22c55e;--warn:#f59e0b;--bg:#f8fafc;--card:#fff;--border:#e2e8f0;--text:#1e293b;--text2:#64748b;--radius:12px}
*{margin:0;padding:0;box-sizing:border-box}
body{font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,sans-serif;background:var(--bg);color:var(--text);min-height:100vh}
.container{max-width:640px;margin:0 auto;padding:16px}
h1{font-size:22px;text-align:center;padding:16px 0 8px;display:flex;align-items:center;justify-content:center;gap:8px}
.card{background:var(--card);border-radius:var(--radius);padding:16px;margin-bottom:12px;box-shadow:0 1px 3px rgba(0,0,0,.06)}
.card-title{font-size:14px;font-weight:600;margin-bottom:10px;color:var(--text2)}
.banner{background:linear-gradient(135deg,#6366f1,#8b5cf6);color:#fff;border-radius:var(--radius);padding:20px;margin-bottom:16px;text-align:center}
.banner h2{font-size:18px;margin-bottom:6px}
.banner p{font-size:13px;opacity:.85}
label{display:block;font-size:13px;font-weight:500;margin-bottom:4px;color:var(--text2)}
input[type=text],input[type=password],select,textarea{width:100%;padding:8px 12px;border:1px solid var(--border);border-radius:8px;font-size:14px;outline:none;transition:border .2s}
input:focus,select:focus{border-color:var(--primary)}
.row{display:flex;gap:8px;align-items:flex-end}
.row>*:first-child{flex:1}
.btn{display:inline-flex;align-items:center;justify-content:center;gap:6px;padding:10px 20px;border:none;border-radius:8px;font-size:14px;font-weight:500;cursor:pointer;transition:all .15s}
.btn-primary{background:var(--primary);color:#fff}
.btn-primary:hover{background:#4338ca}
.btn-primary:disabled{background:#a5b4fc;cursor:not-allowed}
.btn-outline{background:#fff;color:var(--primary);border:1.5px solid var(--primary)}
.btn-outline:hover{background:var(--primary-light)}
.btn-danger{background:var(--danger);color:#fff}
.btn-sm{padding:6px 12px;font-size:12px}
.btn-block{width:100%}
.btn-lg{padding:14px 24px;font-size:16px}
.status-bar{display:flex;flex-wrap:wrap;gap:6px;margin-bottom:8px}
.chip{display:inline-block;padding:4px 10px;border-radius:20px;font-size:12px;font-weight:500}
.chip-ok{background:#dcfce7;color:#166534}
.chip-warn{background:#fef3c7;color:#92400e}
.chip-err{background:#fee2e2;color:#991b1b}
.chip-info{background:#e0e7ff;color:#3730a3}
.progress-bar{width:100%;height:6px;background:#e2e8f0;border-radius:3px;overflow:hidden;margin:8px 0}
.progress-bar-inner{height:100%;background:var(--primary);transition:width .3s}
.upload-area{border:2px dashed var(--border);border-radius:var(--radius);padding:32px;text-align:center;cursor:pointer;transition:border .2s}
.upload-area:hover{border-color:var(--primary)}
.upload-area.dragging{border-color:var(--primary);background:var(--primary-light)}
.upload-area p{color:var(--text2);font-size:14px;margin-top:8px}
.upload-area .icon{font-size:40px}
.task-item{border:1px solid var(--border);border-radius:8px;padding:12px;margin-bottom:8px}
.task-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:6px}
.task-status{font-size:12px;font-weight:600}
.task-details{margin-top:6px}
.task-details summary{font-size:12px;color:var(--primary);cursor:pointer;user-select:none;padding:4px 0;font-weight:500}
.task-details summary:hover{text-decoration:underline}
.task-cards{overflow-x:auto;margin-top:6px}
.task-cards table{width:100%;border-collapse:collapse;font-size:12px;min-width:500px}
.task-cards th,.task-cards td{padding:6px 8px;border:1px solid var(--border);text-align:left;white-space:nowrap}
.task-cards th{background:var(--primary-light);font-weight:600}
.task-error{color:var(--danger);font-size:12px;margin-top:6px;word-break:break-all}
.hidden{display:none!important}
.tabs{display:flex;gap:4px;margin-bottom:12px}
.tab{padding:8px 16px;border-radius:8px;cursor:pointer;font-size:13px;font-weight:500;background:#f1f5f9;color:var(--text2)}
.tab.active{background:var(--primary);color:#fff}
.settings-toggle{text-align:right;margin-bottom:8px}
.settings-toggle a{font-size:13px;color:var(--primary);cursor:pointer;text-decoration:none}
.fade-in{animation:fadeIn .3s ease-in}
@keyframes fadeIn{from{opacity:0;transform:translateY(8px)}to{opacity:1;transform:none}}
.toast{position:fixed;top:20px;left:50%;transform:translateX(-50%);padding:10px 24px;border-radius:8px;font-size:14px;color:#fff;z-index:9999;opacity:0;transition:opacity .3s}
.toast.show{opacity:1}
.toast-ok{background:#22c55e}
.toast-err{background:#ef4444}
.toast-info{background:#6366f1}
.flex-center{display:flex;align-items:center;gap:8px}
@media(max-width:480px){.container{padding:10px}}
.toggle-track{position:relative;display:inline-block;width:44px;height:24px;cursor:pointer;vertical-align:middle}
.toggle-track input{display:none}
.toggle-track .track{position:absolute;inset:0;background:#cbd5e1;border-radius:12px;transition:.3s}
.toggle-track input:checked+.track{background:var(--primary)}
.toggle-track .thumb{position:absolute;left:2px;top:2px;width:20px;height:20px;background:#fff;border-radius:50%;transition:.3s;box-shadow:0 1px 3px rgba(0,0,0,.15)}
.toggle-track input:checked~.thumb{left:22px}
.dual-grid{display:grid;grid-template-columns:1fr 1fr;gap:8px}
.dual-grid .upload-area{padding:16px}
.dual-grid .upload-area .icon{font-size:28px}
.staging-info{text-align:center;font-size:12px;color:var(--text2);margin-top:4px}
</style>
</head>
<body>
<div class="container">
  <h1>ğŸ“‡ åç‰‡æ‰«æåŠ©æ‰‹</h1>

  <!-- Banner -->
  <div class="banner">
    <h2>é«˜æ•ˆå½•å…¥åç‰‡</h2>
    <p>æ‹ç…§/ä¸Šä¼  â†’ AI è¯†åˆ« â†’ è‡ªåŠ¨å†™å…¥é£ä¹¦å¤šç»´è¡¨</p>
  </div>

  <!-- Status -->
  <div class="card" id="statusCard">
    <div class="status-bar" id="statusBar"></div>
  </div>

  <!-- Settings Toggle -->
  <div class="settings-toggle">
    <a onclick="toggleSettings()">âš™ï¸ é…ç½®è®¾ç½®</a>
  </div>

  <!-- Settings Panel -->
  <div class="card hidden" id="settingsPanel">
    <div class="card-title">AI æ¨¡å‹</div>
    <div style="margin-bottom:12px">
      <select id="aiModelSelect" onchange="onAiModelChange(this.value)" style="width:100%"></select>
    </div>
    <div class="card-title">é£ä¹¦å¤šç»´è¡¨é…ç½®</div>
    <div style="margin-bottom:12px">
      <label>å¤šç»´è¡¨é“¾æ¥</label>
      <div class="row">
        <input type="text" id="bitableUrl" placeholder="https://...feishu.cn/base/...">
        <button class="btn btn-outline btn-sm" onclick="parseBitableUrl()">è§£æ</button>
      </div>
      <div style="font-size:12px;color:var(--text2);margin-top:4px">
        App Token: <span id="dispAppToken">æœªé…ç½®</span> &nbsp;|&nbsp; Table ID: <span id="dispTableId">æœªé…ç½®</span>
      </div>
    </div>
    <div style="margin-bottom:8px">
      <button class="btn btn-outline btn-sm" onclick="initBitableTable()">åˆå§‹åŒ–åç‰‡è¡¨æ ¼</button>
    </div>
  </div>

  <!-- Upload Area -->
  <div class="card">
    <!-- åŒé¢åç‰‡å¼€å…³ -->
    <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:12px">
      <span style="font-size:13px;font-weight:500">åŒé¢åç‰‡æ¨¡å¼ <span style="font-size:11px;color:var(--text2)">(ä¸­è‹±æ–‡è‡ªåŠ¨åŒ¹é…åˆå¹¶)</span></span>
      <label class="toggle-track">
        <input type="checkbox" id="dualModeToggle" onchange="toggleDualMode(this.checked)">
        <span class="track"></span>
        <span class="thumb"></span>
      </label>
    </div>

    <!-- å•é¢æ¨¡å¼ -->
    <div id="singleUpload">
      <div class="upload-area" id="uploadArea" onclick="document.getElementById('galleryInput').click()">
        <div class="icon">ğŸ“¸</div>
        <p>ç‚¹å‡»ä¸Šä¼ åç‰‡ç…§ç‰‡ï¼Œæˆ–æ‹–æ‹½åˆ°æ­¤å¤„</p>
        <p style="font-size:12px;color:#94a3b8">æ”¯æŒ JPG / PNG / HEICï¼Œå¯å¤šé€‰</p>
      </div>
      <input type="file" id="cameraInput" accept="image/*" capture="environment" class="hidden" onchange="handleFiles(this.files)">
      <input type="file" id="galleryInput" accept="image/*" multiple class="hidden" onchange="handleFiles(this.files)">
      <div style="display:flex;gap:8px;margin-top:8px">
        <button class="btn btn-primary btn-lg" style="flex:1" onclick="document.getElementById('cameraInput').click()">ğŸ“· æ‹ç…§</button>
        <button class="btn btn-outline btn-lg" style="flex:1" onclick="document.getElementById('galleryInput').click()">ğŸ–¼ï¸ ä»ç›¸å†Œé€‰æ‹©</button>
      </div>
    </div>

    <!-- åŒé¢æ¨¡å¼ -->
    <div id="dualUpload" class="hidden">
      <p style="font-size:12px;color:var(--text2);margin-bottom:8px">åˆ†åˆ«ä¸Šä¼ åç‰‡æ­£é¢ï¼ˆä¸­æ–‡ï¼‰å’ŒèƒŒé¢ï¼ˆè‹±æ–‡ï¼‰ï¼Œç³»ç»Ÿè‡ªåŠ¨æŒ‰ç”µè¯/é‚®ç®±åŒ¹é…å¹¶åˆå¹¶</p>
      <div class="dual-grid">
        <div>
          <div class="upload-area" onclick="document.getElementById('dualFrontInput').click()">
            <div class="icon">ğŸ“‡</div>
            <p style="font-size:13px;font-weight:500">æ­£é¢ï¼ˆä¸­æ–‡ï¼‰</p>
          </div>
          <div class="staging-info" id="frontCount">å·²é€‰ 0 å¼ </div>
        </div>
        <div>
          <div class="upload-area" onclick="document.getElementById('dualBackInput').click()">
            <div class="icon">ğŸ”„</div>
            <p style="font-size:13px;font-weight:500">èƒŒé¢ï¼ˆè‹±æ–‡ï¼‰</p>
          </div>
          <div class="staging-info" id="backCount">å·²é€‰ 0 å¼ </div>
        </div>
      </div>
      <input type="file" id="dualFrontInput" accept="image/*" multiple class="hidden" onchange="handleDualFiles('front', this.files)">
      <input type="file" id="dualBackInput" accept="image/*" multiple class="hidden" onchange="handleDualFiles('back', this.files)">
      <div style="display:flex;gap:8px;margin-top:10px">
        <button class="btn btn-primary btn-lg" style="flex:1" id="dualProcessBtn" onclick="startDualProcess()" disabled>å¼€å§‹å¤„ç†åŒé¢åç‰‡</button>
        <button class="btn btn-outline btn-sm" onclick="clearDualStaging()" style="flex-shrink:0">æ¸…ç©º</button>
      </div>
    </div>
  </div>

  <!-- Queue Stats -->
  <div class="card" id="queueCard">
    <div class="card-title">è¯†åˆ«é˜Ÿåˆ—</div>
    <div class="progress-bar"><div class="progress-bar-inner" id="progressBar" style="width:0%"></div></div>
    <div style="font-size:13px;color:var(--text2)" id="queueStats">å½“å‰æ— ä»»åŠ¡</div>
  </div>

  <!-- Task List -->
  <div class="card">
    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
      <div class="card-title" style="margin:0">è¯†åˆ«ç»“æœ</div>
      <div style="position:relative;display:inline-block" id="clearDropdown">
        <button class="btn btn-danger btn-sm" onclick="toggleClearMenu()">æ¸…ç† â–¾</button>
        <div id="clearMenu" class="hidden" style="position:absolute;right:0;top:100%;margin-top:4px;background:#fff;border:1px solid var(--border);border-radius:8px;box-shadow:0 4px 12px rgba(0,0,0,.12);z-index:100;min-width:140px;padding:4px 0">
          <div style="padding:8px 14px;font-size:13px;cursor:pointer;white-space:nowrap" onclick="clearByStatus('failed')" onmouseover="this.style.background='#f1f5f9'" onmouseout="this.style.background=''">æ¸…ç†å¤±è´¥ä»»åŠ¡</div>
          <div style="padding:8px 14px;font-size:13px;cursor:pointer;white-space:nowrap" onclick="clearByStatus('completed')" onmouseover="this.style.background='#f1f5f9'" onmouseout="this.style.background=''">æ¸…ç†å·²å®Œæˆ</div>
          <div style="padding:8px 14px;font-size:13px;cursor:pointer;white-space:nowrap" onclick="clearByStatus('pending')" onmouseover="this.style.background='#f1f5f9'" onmouseout="this.style.background=''">æ¸…ç†æ’é˜Ÿä¸­</div>
          <div style="border-top:1px solid var(--border);margin:4px 0"></div>
          <div style="padding:8px 14px;font-size:13px;cursor:pointer;white-space:nowrap;color:var(--danger)" onclick="clearByStatus('all')" onmouseover="this.style.background='#fee2e2'" onmouseout="this.style.background=''">æ¸…ç©ºå…¨éƒ¨</div>
        </div>
      </div>
    </div>
    <div class="tabs" id="filterTabs">
      <div class="tab active" onclick="setFilter('all')">å…¨éƒ¨</div>
      <div class="tab" onclick="setFilter('failed')">å¤±è´¥</div>
      <div class="tab" onclick="setFilter('completed')">å·²å®Œæˆ</div>
    </div>
    <div id="taskList"><div style="text-align:center;color:var(--text2);padding:20px;font-size:14px">æš‚æ— è¯†åˆ«è®°å½•</div></div>
  </div>

  <!-- Guide -->
  <div class="card">
    <div class="card-title">ä½¿ç”¨æŒ‡å¼•</div>
    <ol style="font-size:13px;color:var(--text2);padding-left:20px;line-height:1.8">
      <li>ç‚¹å‡»"é…ç½®è®¾ç½®"ï¼Œç²˜è´´å¤šç»´è¡¨é“¾æ¥å¹¶è§£æ</li>
      <li>ç‚¹å‡»"åˆå§‹åŒ–åç‰‡è¡¨æ ¼"åˆ›å»ºå­—æ®µï¼ˆé¦–æ¬¡ä½¿ç”¨ï¼‰</li>
      <li>ä¸Šä¼ æˆ–æ‹ç…§åç‰‡å›¾ç‰‡</li>
      <li>è‡ªåŠ¨è¯†åˆ«å¹¶å†™å…¥é£ä¹¦å¤šç»´è¡¨</li>
    </ol>
  </div>
</div>

<!-- Toast -->
<div class="toast" id="toast"></div>

<script>
// ========== Config & Storage ==========
const STORAGE_KEY = 'card_scanner_config';
const TASKS_KEY = 'card_scanner_tasks';

// Credentials are injected server-side â€” NOT exposed in frontend code
const FIXED_AIHUB_ENV = 'prod';

// AI æ¨¡å‹é…ç½®
const AI_MODELS = {
  doubao: { label: 'è±†åŒ… Doubao-Seed-1.8', modelId: 'doubao-seed-1.8', provider: 'doubao' },
  gemini: { label: 'Gemini 3 Pro', modelId: 'gemini-3-pro-preview', provider: 'gemini' },
};
const DEFAULT_AI_MODEL = 'doubao';

// When running via local proxy (server.js), API calls go through /api/... to avoid CORS.
const PROXY_BASE = location.protocol === 'file:' ? '' : '';
const FEISHU_BASE = '/api/feishu/';
const DOUBAO_URLS = {
  prod: '/api/doubao-prod/',
  pre: '/api/doubao-pre/',
  test: '/api/doubao-test/',
};
const GEMINI_URLS = {
  prod: '/api/aihub-prod/',
  pre: '/api/aihub-pre/',
  test: '/api/aihub-test/',
};

function loadConfig() {
  let cfg;
  try { cfg = JSON.parse(localStorage.getItem(STORAGE_KEY)) || {}; } catch { cfg = {}; }
  cfg.aihubEnv = FIXED_AIHUB_ENV;
  if (!cfg.aiModel || !AI_MODELS[cfg.aiModel]) cfg.aiModel = DEFAULT_AI_MODEL;
  return cfg;
}
function saveConfig(cfg) { localStorage.setItem(STORAGE_KEY, JSON.stringify(cfg)); }
function loadTasks() {
  try { return JSON.parse(localStorage.getItem(TASKS_KEY)) || []; } catch { return []; }
}
function saveTasks(tasks) { localStorage.setItem(TASKS_KEY, JSON.stringify(tasks)); }

// ========== Toast ==========
function toast(msg, type = 'info') {
  const el = document.getElementById('toast');
  el.textContent = msg;
  el.className = 'toast show toast-' + type;
  setTimeout(() => el.classList.remove('show'), 3000);
}

// ========== Settings UI ==========
function toggleSettings() {
  const p = document.getElementById('settingsPanel');
  p.classList.toggle('hidden');
}

function loadSettingsUI() {
  const c = loadConfig();
  document.getElementById('bitableUrl').value = '';
  document.getElementById('dispAppToken').textContent = c.appToken || 'æœªé…ç½®';
  document.getElementById('dispTableId').textContent = c.tableId || 'æœªé…ç½®';
  refreshStatus();
}

function parseBitableUrl() {
  const url = document.getElementById('bitableUrl').value.trim();
  if (!url) { toast('è¯·å…ˆç²˜è´´é“¾æ¥', 'err'); return; }
  try {
    const u = new URL(url);
    const segs = u.pathname.split('/');
    const baseIdx = segs.indexOf('base');
    const appToken = baseIdx >= 0 && baseIdx + 1 < segs.length ? segs[baseIdx + 1] : null;
    const tableId = u.searchParams.get('table') || '';
    if (!appToken) throw new Error('æ— æ³•æå– App Token');
    const c = loadConfig();
    c.appToken = appToken;
    c.tableId = tableId;
    saveConfig(c);
    document.getElementById('dispAppToken').textContent = appToken;
    document.getElementById('dispTableId').textContent = tableId || 'æœªæ£€æµ‹åˆ°';
    refreshStatus();
    toast(`è§£ææˆåŠŸ! App Token: ${appToken}`, 'ok');
  } catch (e) {
    toast('è§£æå¤±è´¥: ' + e.message, 'err');
  }
}

// ========== Status ==========
function refreshStatus() {
  const c = loadConfig();
  const bar = document.getElementById('statusBar');
  const items = [];
  items.push({t:'é£ä¹¦å‡­è¯ âœ“ (æœåŠ¡ç«¯)',cls:'chip-ok'});
  items.push({t:'AI Key âœ“ (æœåŠ¡ç«¯)',cls:'chip-ok'});
  items.push(c.appToken && c.tableId ? {t:'å¤šç»´è¡¨ âœ“',cls:'chip-ok'} : {t:'å¤šç»´è¡¨ âœ—',cls:'chip-warn'});
  items.push({t:'ç¯å¢ƒ: ç”Ÿäº§', cls:'chip-info'});
  bar.innerHTML = items.map(i => `<span class="chip ${i.cls}">${i.t}</span>`).join('');
}

// ========== Feishu API ==========
let tenantToken = null;
let tenantTokenExpire = 0;

// Wrap fetch to provide friendly error messages instead of raw "Failed to fetch"
// err.message = friendly display text, err.rawDetail = original error for copy
async function safeFetch(url, options) {
  let resp;
  try {
    resp = await fetch(url, options);
  } catch (e) {
    const short = url.replace(/https?:\/\/[^/]+/, '').slice(0, 60);
    const raw = `${e.name}: ${e.message} | URL: ${url}`;
    const err = new Error(`ç½‘ç»œè¯·æ±‚å¤±è´¥ (${short})ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥æˆ–æœåŠ¡å™¨æ˜¯å¦æ­£å¸¸è¿è¡Œ`);
    err.rawDetail = raw;
    err._noRetry = true;
    throw err;
  }
  return resp;
}

// Helper: build an error with both friendly message and raw detail
function makeApiError(friendlyMsg, rawDetail) {
  const err = new Error(friendlyMsg);
  err.rawDetail = rawDetail;
  return err;
}

async function ensureTenantToken(forceRefresh = false) {
  const now = Date.now() / 1000;
  if (!forceRefresh && tenantToken && now < tenantTokenExpire) return;
  // Call server-side endpoint â€” credentials never leave the server
  const resp = await safeFetch('/api/internal/tenant-token', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json; charset=utf-8' },
  });
  const data = await resp.json();
  if (data.code !== 0) throw makeApiError('è·å–é£ä¹¦å‡­è¯å¤±è´¥', JSON.stringify(data));
  tenantToken = data.tenant_access_token;
  tenantTokenExpire = now + (data.expire || 7200) - 120;
}

async function feishuPost(url, body, isFormData = false) {
  await ensureTenantToken();
  const headers = { 'Authorization': 'Bearer ' + tenantToken };
  if (!isFormData) headers['Content-Type'] = 'application/json; charset=utf-8';
  let resp = await safeFetch(url, {method:'POST', headers, body: isFormData ? body : JSON.stringify(body)});
  if (resp.status === 401) {
    await ensureTenantToken(true);
    headers['Authorization'] = 'Bearer ' + tenantToken;
    resp = await safeFetch(url, {method:'POST', headers, body: isFormData ? body : JSON.stringify(body)});
  }
  // å®‰å…¨è§£æ JSONï¼šå¦‚æœå“åº”ä¸æ˜¯ JSONï¼ˆå¦‚ gzip ä¹±ç ã€HTML é”™è¯¯é¡µï¼‰ï¼Œç»™å‡ºå¯è¯»æŠ¥é”™
  let data;
  const rawText = await resp.text();
  try {
    data = JSON.parse(rawText);
  } catch (parseErr) {
    const preview = rawText.slice(0, 300);
    throw makeApiError(
      `é£ä¹¦æ¥å£è¿”å›äº†é JSON æ•°æ® (HTTP ${resp.status})ï¼Œå¯èƒ½æ˜¯ç½‘ç»œ/ä»£ç†å¼‚å¸¸`,
      `HTTP ${resp.status} | URL: ${url} | Parse error: ${parseErr.message} | Body preview: ${preview}`
    );
  }
  if (!resp.ok && resp.status >= 400) throw makeApiError(`é£ä¹¦æ¥å£é”™è¯¯ (${resp.status})`, `HTTP ${resp.status} | URL: ${url} | Body: ${JSON.stringify(data).slice(0,500)}`);
  return data;
}

async function feishuUploadImage(file, parentNode) {
  await ensureTenantToken();
  const fd = new FormData();
  fd.append('file_name', file.name);
  fd.append('parent_type', 'bitable_image');
  fd.append('parent_node', parentNode);
  fd.append('size', file.size);
  fd.append('file', file);
  const data = await feishuPost(FEISHU_BASE + 'drive/v1/medias/upload_all', fd, true);
  if (data.code === 0) return data.data.file_token;
  throw makeApiError('ä¸Šä¼ å›¾ç‰‡å¤±è´¥', JSON.stringify(data));
}

async function feishuAddRecords(appToken, tableId, records) {
  const data = await feishuPost(
    `${FEISHU_BASE}bitable/v1/apps/${appToken}/tables/${tableId}/records/batch_create`,
    { records: records.map(r => ({ fields: r })) }
  );
  if (data.code === 0) return data.data.records.map(r => r.record_id);
  throw makeApiError('å†™å…¥è®°å½•å¤±è´¥', JSON.stringify(data));
}

async function initBitableTable() {
  const c = loadConfig();
  if (!c.appToken) { toast('è¯·å…ˆè§£æå¤šç»´è¡¨é“¾æ¥', 'err'); return; }
  try {
    const data = await feishuPost(
      `${FEISHU_BASE}bitable/v1/apps/${c.appToken}/tables`,
      { table: {
        name: 'åç‰‡æ•°æ®', default_view_name: 'è¡¨æ ¼è§†å›¾',
        fields: [
          {field_name:'å§“å',type:1,ui_type:'Text'},
          {field_name:'ç”µè¯',type:1,ui_type:'Text'},
          {field_name:'å…¬å¸',type:1,ui_type:'Text'},
          {field_name:'èŒä½',type:1,ui_type:'Text'},
          {field_name:'é‚®ç®±',type:1,ui_type:'Text'},
          {field_name:'åœ°å€',type:1,ui_type:'Text'},
          {field_name:'å½•å…¥æ—¶é—´',type:1001,ui_type:'CreatedTime'},
          {field_name:'æ¥æºå›¾ç‰‡',type:17,ui_type:'Attachment'},
        ]
      }}
    );
    if (data.code === 0) {
      c.tableId = data.data.table_id;
      saveConfig(c);
      document.getElementById('dispTableId').textContent = c.tableId;
      refreshStatus();
      toast('è¡¨æ ¼åˆå§‹åŒ–æˆåŠŸ! Table ID: ' + c.tableId, 'ok');
    } else {
      throw new Error(JSON.stringify(data));
    }
  } catch (e) { toast('åˆå§‹åŒ–å¤±è´¥: ' + e.message, 'err'); }
}

// ========== AI æ¨¡å‹åˆ‡æ¢ ==========
function onAiModelChange(key) {
  const c = loadConfig();
  c.aiModel = key;
  saveConfig(c);
  toast('å·²åˆ‡æ¢åˆ°: ' + AI_MODELS[key].label, 'ok');
}

function initModelSelector() {
  const sel = document.getElementById('aiModelSelect');
  if (!sel) return;
  const c = loadConfig();
  sel.innerHTML = Object.entries(AI_MODELS).map(([k, v]) =>
    `<option value="${k}" ${k === c.aiModel ? 'selected' : ''}>${v.label}</option>`
  ).join('');
}

const CARD_PROMPT = `ä½ æ˜¯ä¸€åä¸“ä¸šçš„åç‰‡ç»“æ„åŒ–è§£æå¼•æ“ã€‚è¯·è¯†åˆ«å›¾ç‰‡ä¸­çš„å…¨éƒ¨åç‰‡å¹¶è¾“å‡ºç»“æ„åŒ– JSONã€‚
ä»…è¾“å‡º JSON æ•°ç»„ï¼Œä¸è¦ Markdownï¼Œä¸è¦è§£é‡Šã€‚
å­—æ®µå›ºå®šï¼šname, phone, company, title, email, address, remarkã€‚
ç¼ºå¤±å­—æ®µç”¨ç©ºå­—ç¬¦ä¸²ã€‚`;

const CARD_PROMPT_SHORT = 'è¯†åˆ«å›¾ç‰‡ä¸­æ‰€æœ‰åç‰‡ï¼Œè¿”å› JSON æ•°ç»„ï¼Œæ¯é¡¹åŒ…å« name,phone,company,title,email,address,remarkã€‚ä»…è¾“å‡º JSONï¼Œä¸è¦è§£é‡Šã€‚ç¼ºå¤±å­—æ®µç”¨ç©ºå­—ç¬¦ä¸²ã€‚';

// ç»Ÿä¸€å…¥å£ï¼šæ ¹æ®é…ç½®é€‰æ‹©æ¨¡å‹
async function callGemini(base64Image) {
  const c = loadConfig();
  const modelKey = c.aiModel || DEFAULT_AI_MODEL;
  const modelCfg = AI_MODELS[modelKey];
  if (modelCfg.provider === 'gemini') return callGeminiProvider(base64Image, c);
  return callDoubaoProvider(base64Image, c);
}

// ========== Doubao (è±†åŒ…) â€” OpenAI chat/completions å…¼å®¹æ ¼å¼ ==========
async function callDoubaoProvider(base64Image, c) {
  const env = c.aihubEnv || 'prod';
  const baseUrl = DOUBAO_URLS[env] || DOUBAO_URLS.prod;
  const model = AI_MODELS.doubao.modelId;
  const url = `${baseUrl}chat/completions`;

  const body = {
    model: model,
    messages: [{
      role: 'user',
      content: [
        { type: 'text', text: CARD_PROMPT },
        { type: 'image_url', image_url: { url: `data:image/jpeg;base64,${base64Image}` } }
      ]
    }],
    temperature: 0.0,
    max_tokens: 4096,
    stream: false
  };

  const headers = { 'Content-Type': 'application/json' };
  let lastError;
  for (let attempt = 0; attempt < 3; attempt++) {
    try {
      const resp = await safeFetch(url, { method:'POST', headers, body: JSON.stringify(body) });
      if (!resp.ok) { await throwHttpError(resp, url); }
      const data = await resp.json();
      checkAihubError(data);

      let rawText = extractDoubaoText(data);

      const finishReason = data.choices && data.choices[0] ? (data.choices[0].finish_reason || '') : '';
      if (finishReason === 'length' || (!rawText && data.choices && data.choices.length)) {
        body.max_tokens = 8192;
        body.messages[0].content[0].text = CARD_PROMPT_SHORT;
        const resp2 = await safeFetch(url, { method:'POST', headers, body: JSON.stringify(body) });
        const data2 = await resp2.json();
        const rawText2 = extractDoubaoText(data2);
        if (rawText2) rawText = rawText2;
      }

      if (!rawText) throw new Error('æ¨¡å‹æœªè¿”å›æ–‡æœ¬å†…å®¹');
      return parseCards(rawText);
    } catch (e) {
      lastError = e;
      if (e._canRetry) { await new Promise(r => setTimeout(r, 800 * Math.pow(2, attempt))); continue; }
      break;
    }
  }
  throw lastError;
}

function extractDoubaoText(data) {
  if (data.choices && data.choices.length) {
    const msg = data.choices[0].message;
    if (msg && msg.content && msg.content.trim()) return msg.content;
  }
  return null;
}

// ========== Gemini â€” Google generateContent æ ¼å¼ ==========
async function callGeminiProvider(base64Image, c) {
  const env = c.aihubEnv || 'prod';
  const baseUrl = GEMINI_URLS[env] || GEMINI_URLS.prod;
  const model = AI_MODELS.gemini.modelId;
  const url = `${baseUrl}${model}:generateContent`;

  const body = {
    contents: [{ role: 'user', parts: [
      { text: CARD_PROMPT },
      { inlineData: { mimeType: 'image/jpeg', data: base64Image } }
    ]}],
    generationConfig: { temperature: 0.0, maxOutputTokens: 4096 }
  };

  const headers = { 'Content-Type': 'application/json' };
  let lastError;
  for (let attempt = 0; attempt < 3; attempt++) {
    try {
      const resp = await safeFetch(url, { method:'POST', headers, body: JSON.stringify(body) });
      if (!resp.ok) { await throwHttpError(resp, url); }
      const data = await resp.json();
      checkAihubError(data);

      let candidates = data.candidates || (data.data && data.data.candidates);
      let rawText = extractGeminiText(candidates);

      const finishReason = candidates && candidates[0] ? (candidates[0].finishReason || '') : '';
      if (finishReason === 'MAX_TOKENS' || (!rawText && candidates && candidates.length)) {
        body.generationConfig.maxOutputTokens = 8192;
        body.contents[0].parts[0].text = CARD_PROMPT_SHORT;
        const resp2 = await safeFetch(url, { method:'POST', headers, body: JSON.stringify(body) });
        const data2 = await resp2.json();
        const candidates2 = data2.candidates || (data2.data && data2.data.candidates);
        const rawText2 = extractGeminiText(candidates2);
        if (rawText2) rawText = rawText2;
      }

      if (!rawText) throw new Error('æ¨¡å‹æœªè¿”å›æ–‡æœ¬å†…å®¹');
      return parseCards(rawText);
    } catch (e) {
      lastError = e;
      if (e._canRetry) { await new Promise(r => setTimeout(r, 800 * Math.pow(2, attempt))); continue; }
      break;
    }
  }
  throw lastError;
}

function extractGeminiText(candidates) {
  if (!candidates || !candidates.length) return null;
  for (const c of candidates) {
    if (c.content && c.content.parts) {
      for (const p of c.content.parts) {
        if (p.text && p.text.trim() && !p.thought) return p.text;
      }
    }
    if (c.text && c.text.trim()) return c.text;
  }
  return null;
}

// ========== å…±ç”¨ï¼šHTTP é”™è¯¯ & AIHub ç½‘å…³é”™è¯¯å¤„ç† ==========
async function throwHttpError(resp, url) {
  const errText = await resp.text().catch(() => '');
  const raw = `HTTP ${resp.status} | URL: ${url} | Body: ${errText.slice(0, 500)}`;
  let msg = `AI æœåŠ¡ HTTP ${resp.status}`;
  if (resp.status === 403) msg = 'AI æœåŠ¡æ‹’ç»è®¿é—® (403)ï¼Œè¯·ç¡®è®¤ç½‘ç»œç¯å¢ƒå¯è®¿é—® AIHub';
  if (resp.status === 401) msg = 'AI æœåŠ¡é‰´æƒå¤±è´¥ (401)ï¼Œè¯·æ£€æŸ¥ API-KEY';
  const err = makeApiError(msg, raw);
  err._noRetry = true;
  throw err;
}

function checkAihubError(data) {
  const code = data.code;
  if (code === 61100001 || String(code) === '61100001') {
    const err = new Error('AIHub æš‚æ—¶ä¸å¯ç”¨ï¼Œé‡è¯•ä¸­...');
    err._canRetry = true;
    throw err;
  }
  if (code !== undefined && code !== null && code !== 0) {
    const err = makeApiError(`AIHub error: code=${code}`, `code=${code}, msg=${data.msg}`);
    err._noRetry = true;
    throw err;
  }
}

function parseCards(rawText) {
  let s = rawText.trim();
  // Strip markdown fences
  if (s.startsWith('```json')) s = s.slice(7);
  else if (s.startsWith('```')) s = s.slice(3);
  if (s.endsWith('```')) s = s.slice(0, -3);
  s = s.trim();

  // Try normal parse first
  try {
    const parsed = JSON.parse(s);
    return Array.isArray(parsed) ? parsed : [parsed];
  } catch (_) { /* fall through to repair */ }

  // Attempt to repair truncated JSON array
  // Strategy: find last complete object "}" before truncation, close the array
  const repaired = repairTruncatedJsonArray(s);
  if (repaired && repaired.length > 0) return repaired;

  throw new Error('JSON è§£æå¤±è´¥ï¼Œæ¨¡å‹è¾“å‡ºå¯èƒ½è¢«æˆªæ–­ã€‚åŸå§‹æ–‡æœ¬å‰200å­—: ' + s.slice(0, 200));
}

function repairTruncatedJsonArray(s) {
  // Ensure it starts with '['
  if (!s.startsWith('[')) {
    // Maybe a single truncated object
    if (s.startsWith('{')) {
      // Try to close the object
      const fixed = tryCloseObject(s);
      if (fixed) return [fixed];
    }
    return null;
  }

  // Find the last complete '}' that ends a valid object boundary
  // Walk backwards to find a good cut point
  for (let i = s.length - 1; i > 0; i--) {
    if (s[i] === '}') {
      const candidate = s.slice(0, i + 1) + ']';
      try {
        const parsed = JSON.parse(candidate);
        if (Array.isArray(parsed) && parsed.length > 0) {
          console.log(`[parseCards] Repaired truncated JSON: kept ${parsed.length} cards, cut at position ${i+1}/${s.length}`);
          return parsed;
        }
      } catch (_) { continue; }
    }
  }
  return null;
}

function tryCloseObject(s) {
  // Try progressively trimming from the end and closing braces
  for (let i = s.length - 1; i > 0; i--) {
    // Find last complete key-value pair
    if (s[i] === '"' || s[i] === ',' || s[i] === '}') {
      // Try closing at various points
      let candidate = s.slice(0, i + 1);
      // Count open/close braces
      const opens = (candidate.match(/\{/g) || []).length;
      const closes = (candidate.match(/\}/g) || []).length;
      candidate += '}'.repeat(Math.max(0, opens - closes));
      try {
        return JSON.parse(candidate);
      } catch (_) { continue; }
    }
  }
  return null;
}

// ========== File Handling & Persistent Image Storage (IndexedDB) ==========
function fileToBase64(file) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = () => {
      const dataUrl = reader.result;
      resolve(dataUrl.split(',')[1]); // strip "data:image/...;base64,"
    };
    reader.onerror = reject;
    reader.readAsDataURL(file);
  });
}

function fileToDataUrl(file) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = () => resolve(reader.result);
    reader.onerror = reject;
    reader.readAsDataURL(file);
  });
}

function dataUrlToBase64(dataUrl) {
  return dataUrl.split(',')[1];
}

function dataUrlToBlob(dataUrl) {
  const parts = dataUrl.split(',');
  const mime = parts[0].match(/:(.*?);/)[1];
  const b64 = atob(parts[1]);
  const arr = new Uint8Array(b64.length);
  for (let i = 0; i < b64.length; i++) arr[i] = b64.charCodeAt(i);
  return new Blob([arr], { type: mime });
}

function dataUrlToFile(dataUrl, fileName) {
  const blob = dataUrlToBlob(dataUrl);
  return new File([blob], fileName, { type: blob.type });
}

// IndexedDB for persistent image storage (survives page refresh)
const IDB_NAME = 'card_scanner_images';
const IDB_STORE = 'images';

function openImageDB() {
  return new Promise((resolve, reject) => {
    const req = indexedDB.open(IDB_NAME, 1);
    req.onupgradeneeded = () => req.result.createObjectStore(IDB_STORE);
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
}

async function saveImageData(taskId, dataUrl) {
  const db = await openImageDB();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(IDB_STORE, 'readwrite');
    tx.objectStore(IDB_STORE).put(dataUrl, String(taskId));
    tx.oncomplete = () => resolve();
    tx.onerror = () => reject(tx.error);
  });
}

async function getImageData(taskId) {
  const db = await openImageDB();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(IDB_STORE, 'readonly');
    const req = tx.objectStore(IDB_STORE).get(String(taskId));
    req.onsuccess = () => resolve(req.result || null);
    req.onerror = () => reject(req.error);
  });
}

async function deleteImageData(taskId) {
  const db = await openImageDB();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(IDB_STORE, 'readwrite');
    tx.objectStore(IDB_STORE).delete(String(taskId));
    tx.oncomplete = () => resolve();
    tx.onerror = () => reject(tx.error);
  });
}

async function clearAllImageData() {
  const db = await openImageDB();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(IDB_STORE, 'readwrite');
    tx.objectStore(IDB_STORE).clear();
    tx.oncomplete = () => resolve();
    tx.onerror = () => reject(tx.error);
  });
}

async function getImageCount() {
  const db = await openImageDB();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(IDB_STORE, 'readonly');
    const req = tx.objectStore(IDB_STORE).count();
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
}

async function getAllImageKeys() {
  const db = await openImageDB();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(IDB_STORE, 'readonly');
    const req = tx.objectStore(IDB_STORE).getAllKeys();
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
}

// Keep at most MAX_CACHED_IMAGES images; evict completed/oldest first
const MAX_CACHED_IMAGES = 30;
async function evictOldImages() {
  const count = await getImageCount();
  if (count <= MAX_CACHED_IMAGES) return;
  const keys = await getAllImageKeys();
  const tasks = loadTasks();
  // Build set of task IDs that still need images (pending/processing/uploading/failed)
  const neededIds = new Set(
    tasks.filter(t => t.status !== 'completed').map(t => String(t.id))
  );
  // Delete images for completed tasks first, then oldest
  // dual ä»»åŠ¡å›¾ç‰‡é”®æ ¼å¼ä¸º "id_f0"/"id_b0"ï¼ŒåŒ¹é…åŸºç¡€ ID
  const toDelete = keys.filter(k => {
    const baseId = String(k).split('_')[0];
    return !neededIds.has(String(k)) && !neededIds.has(baseId);
  });
  const extra = count - MAX_CACHED_IMAGES;
  const deleteBatch = toDelete.slice(0, Math.max(extra, 0));
  for (const k of deleteBatch) {
    await deleteImageData(k).catch(() => {});
  }
}

// ========== Drag & Drop ==========
const uploadArea = document.getElementById('uploadArea');
uploadArea.addEventListener('dragover', e => { e.preventDefault(); uploadArea.classList.add('dragging'); });
uploadArea.addEventListener('dragleave', () => uploadArea.classList.remove('dragging'));
uploadArea.addEventListener('drop', e => { e.preventDefault(); uploadArea.classList.remove('dragging'); handleFiles(e.dataTransfer.files); });

// ========== Task Queue ==========
let currentFilter = 'all';
let processing = false;

async function handleFiles(files) {
  if (!files || !files.length) return;
  const c = loadConfig();
  if (!c.appToken || !c.tableId) { toast('è¯·å…ˆè§£æå¤šç»´è¡¨é“¾æ¥å¹¶åˆå§‹åŒ–è¡¨æ ¼', 'err'); toggleSettings(); return; }

  const tasks = loadTasks();
  for (const file of files) {
    const id = Date.now() + Math.random();
    // Read file to dataUrl and persist to IndexedDB immediately
    const dataUrl = await fileToDataUrl(file);
    await saveImageData(id, dataUrl);
    tasks.unshift({
      id,
      fileName: file.name,
      status: 'pending',
      cards: null,
      error: null,
      createdAt: new Date().toLocaleString(),
    });
  }
  saveTasks(tasks);
  renderTasks();
  refreshQueue();
  evictOldImages().catch(() => {}); // auto cleanup
  processQueue();
}

// Helper: get base64 and File object for a task from IndexedDB
// Returns null if image data is no longer available
async function getTaskImageData(taskId, fileName) {
  const dataUrl = await getImageData(taskId);
  if (!dataUrl) return null;
  const base64 = dataUrlToBase64(dataUrl);
  const file = dataUrlToFile(dataUrl, fileName || 'image.jpg');
  return { base64, file };
}

// Let user re-select a file for a task whose image was evicted
function reSelectFile(taskId) {
  const input = document.createElement('input');
  input.type = 'file';
  input.accept = 'image/*';
  input.onchange = async () => {
    const file = input.files[0];
    if (!file) return;
    const dataUrl = await fileToDataUrl(file);
    await saveImageData(taskId, dataUrl);
    toast('æ–‡ä»¶å·²é‡æ–°å…³è”ï¼Œè¯·å†æ¬¡ç‚¹å‡»é‡è¯•', 'ok');
  };
  input.click();
}

async function processQueue() {
  if (processing) return;
  processing = true;
  while (true) {
    const tasks = loadTasks();
    const idx = tasks.findIndex(t => t.status === 'pending' && t.type !== 'dual');
    if (idx < 0) break;
    const task = tasks[idx];
    task.status = 'processing';
    saveTasks(tasks); renderTasks(); refreshQueue();
    // Yield to browser so UI can repaint before starting network request
    await new Promise(r => setTimeout(r, 50));

    try {
      const imgData = await getTaskImageData(task.id, task.fileName);
      if (!imgData) throw new Error('å›¾ç‰‡ç¼“å­˜å·²æ¸…ç†ï¼Œè¯·ç‚¹å‡»"é‡æ–°é€‰æ‹©æ–‡ä»¶"åé‡è¯•');
      const { base64, file } = imgData;

      const cards = await callGemini(base64);
      task.cards = cards;
      task.status = 'uploading';
      const t2 = loadTasks(); Object.assign(t2.find(t=>t.id===task.id), task); saveTasks(t2); renderTasks(); refreshQueue();
      await new Promise(r => setTimeout(r, 50));

      const c = loadConfig();
      const fileToken = await feishuUploadImage(file, c.appToken);
      const records = cards.map(card => ({
        'å§“å': (card.name||'').trim(),
        'ç”µè¯': formatPhone(card.phone),
        'å…¬å¸': (card.company||'').trim(),
        'èŒä½': (card.title||'').trim(),
        'é‚®ç®±': (card.email||'').trim(),
        'åœ°å€': (card.address||'').trim(),
        'æ¥æºå›¾ç‰‡': [{file_token: fileToken}],
      }));
      await feishuAddRecords(c.appToken, c.tableId, records);

      task.status = 'completed';
      task.error = null;
      // Clean up stored image for completed tasks to save space
      deleteImageData(task.id).catch(() => {});
    } catch (e) {
      task.status = 'failed';
      task.error = e.message || String(e);
      task.errorRaw = e.rawDetail || e.message || String(e);
    }
    const t3 = loadTasks(); Object.assign(t3.find(t=>t.id===task.id)||{}, task); saveTasks(t3); renderTasks(); refreshQueue();
  }
  processing = false;
}

function refreshQueue() {
  const tasks = loadTasks();
  const pending = tasks.filter(t=>t.status==='pending').length;
  const proc = tasks.filter(t=>t.status==='processing').length;
  const uploading = tasks.filter(t=>t.status==='uploading').length;
  const completed = tasks.filter(t=>t.status==='completed').length;
  const failed = tasks.filter(t=>t.status==='failed').length;
  const total = tasks.length;
  const pct = total === 0 ? 0 : Math.round(completed / total * 100);
  document.getElementById('progressBar').style.width = pct + '%';
  document.getElementById('queueStats').textContent =
    total === 0 ? 'å½“å‰æ— ä»»åŠ¡' :
    `æ’é˜Ÿ: ${pending}  è¯†åˆ«ä¸­: ${proc}  ä¸Šä¼ ä¸­: ${uploading}  å®Œæˆ: ${completed}  å¤±è´¥: ${failed}`;
}

function setFilter(f) {
  currentFilter = f;
  document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
  document.querySelector(`.tab[onclick="setFilter('${f}')"]`).classList.add('active');
  renderTasks();
}

function toggleClearMenu() {
  document.getElementById('clearMenu').classList.toggle('hidden');
}
// Close menu when clicking outside
document.addEventListener('click', (e) => {
  const dd = document.getElementById('clearDropdown');
  if (dd && !dd.contains(e.target)) {
    document.getElementById('clearMenu').classList.add('hidden');
  }
});

function clearByStatus(status) {
  document.getElementById('clearMenu').classList.add('hidden');
  const labelMap = {failed:'å¤±è´¥',completed:'å·²å®Œæˆ',pending:'æ’é˜Ÿä¸­',all:'å…¨éƒ¨'};
  if (!confirm(`ç¡®è®¤æ¸…ç†ã€Œ${labelMap[status]}ã€ä»»åŠ¡ï¼Ÿ`)) return;
  if (status === 'all') {
    saveTasks([]);
    clearAllImageData().catch(() => {});
  } else {
    const tasks = loadTasks();
    const toRemove = tasks.filter(t => t.status === status);
    const remaining = tasks.filter(t => t.status !== status);
    // Clean images for removed tasks (æ”¯æŒ dual ä»»åŠ¡çš„å¤šå›¾ç‰‡é”®)
    toRemove.forEach(t => deleteTaskImages(t));
    saveTasks(remaining);
  }
  renderTasks();
  refreshQueue();
  toast(`å·²æ¸…ç†ã€Œ${labelMap[status]}ã€ä»»åŠ¡`, 'ok');
}

function renderTasks() {
  const tasks = loadTasks();
  let filtered = tasks;
  if (currentFilter === 'failed') filtered = tasks.filter(t => t.status === 'failed');
  if (currentFilter === 'completed') filtered = tasks.filter(t => t.status === 'completed');

  const el = document.getElementById('taskList');
  if (!filtered.length) {
    el.innerHTML = '<div style="text-align:center;color:var(--text2);padding:20px;font-size:14px">æš‚æ— è¯†åˆ«è®°å½•</div>';
    return;
  }

  el.innerHTML = filtered.map(task => {
    const statusMap = {pending:'æ’é˜Ÿä¸­',processing:'è¯†åˆ«ä¸­',uploading:'ä¸Šä¼ ä¸­',completed:'å·²å®Œæˆ',failed:'å¤±è´¥'};
    const colorMap = {pending:'var(--warn)',processing:'var(--primary)',uploading:'var(--primary)',completed:'var(--success)',failed:'var(--danger)'};
    const statusText = task.statusDetail || statusMap[task.status] || task.status;
    const isDual = task.type === 'dual';
    const cards = task.cards || [];
    let cardsHtml = '';
    if (cards.length) {
      cardsHtml = `<details class="task-details">
        <summary>æŸ¥çœ‹è¯†åˆ«ç»“æœï¼ˆ${cards.length} å¼ åç‰‡${isDual ? 'ï¼Œå·²åˆå¹¶ä¸­è‹±æ–‡' : ''}ï¼‰</summary>
        <div class="task-cards"><table>
          <tr><th>å§“å</th><th>å…¬å¸</th><th>èŒä½</th><th>ç”µè¯</th><th>é‚®ç®±</th></tr>
          ${cards.map(c=>`<tr><td>${esc(c.name)}</td><td>${esc(c.company)}</td><td>${esc(c.title)}</td><td>${esc(c.phone)}</td><td>${esc(c.email)}</td></tr>`).join('')}
        </table></div>
      </details>`;
    }
    const errorHtml = task.error ? `<div class="task-error" style="display:flex;align-items:flex-start;gap:6px">
      <span style="flex:1">âŒ ${esc(task.error)}</span>
      <button class="btn btn-sm" style="flex-shrink:0;padding:2px 8px;font-size:11px;background:#fee2e2;color:#991b1b;border:1px solid #fca5a5" onclick="copyError(this)" data-err="${esc(task.errorRaw || task.error).replace(/"/g,'&quot;')}">å¤åˆ¶</button>
    </div>` : '';
    // Retry buttons: different actions depending on task type and what failed
    let retryHtml = '';
    if (task.status === 'failed') {
      const hasCards = task.cards && task.cards.length;
      if (isDual) {
        retryHtml = hasCards
          ? `<div style="display:flex;gap:6px;margin-top:6px;flex-wrap:wrap">
              <button class="btn btn-outline btn-sm" onclick="retryDualWrite(${task.id})">ğŸ”„ é‡è¯•å†™å…¥é£ä¹¦</button>
              <button class="btn btn-outline btn-sm" onclick="retryDual(${task.id})">ğŸ” é‡æ–°å¤„ç†</button>
            </div>`
          : `<div style="display:flex;gap:6px;margin-top:6px;flex-wrap:wrap">
              <button class="btn btn-outline btn-sm" onclick="retryDual(${task.id})">ğŸ” é‡æ–°å¤„ç†</button>
            </div>`;
      } else {
        const reselectBtn = `<button class="btn btn-sm" style="background:#f1f5f9;color:var(--text2);border:1px solid var(--border)" onclick="reSelectFile(${task.id})">ğŸ“‚ é‡æ–°é€‰æ‹©æ–‡ä»¶</button>`;
        retryHtml = hasCards
          ? `<div style="display:flex;gap:6px;margin-top:6px;flex-wrap:wrap">
              <button class="btn btn-outline btn-sm" onclick="retryWrite(${task.id})">ğŸ”„ é‡è¯•å†™å…¥é£ä¹¦</button>
              <button class="btn btn-outline btn-sm" onclick="retryAll(${task.id})">ğŸ” é‡æ–°è¯†åˆ«+å†™å…¥</button>
            </div>`
          : `<div style="display:flex;gap:6px;margin-top:6px;flex-wrap:wrap">
              <button class="btn btn-outline btn-sm" onclick="retryAll(${task.id})">ğŸ” é‡æ–°è¯†åˆ«</button>
              ${reselectBtn}
            </div>`;
      }
    }

    return `<div class="task-item fade-in">
      <div class="task-header">
        <span style="font-size:13px;font-weight:500">${isDual ? 'ğŸ“‘ ' : ''}${esc(task.fileName)}</span>
        <span class="task-status" style="color:${colorMap[task.status]}">${statusText}</span>
      </div>
      <div style="font-size:11px;color:var(--text2)">${task.createdAt} Â· åç‰‡æ•°: ${cards.length}</div>
      ${cardsHtml}${errorHtml}${retryHtml}
    </div>`;
  }).join('');
}

async function retryWrite(taskId) {
  const tasks = loadTasks();
  const task = tasks.find(t => t.id === taskId);
  if (!task || !task.cards || !task.cards.length) { toast('æ— å¯é‡è¯•æ•°æ®', 'err'); return; }
  task.status = 'uploading';
  task.error = null;
  saveTasks(tasks); renderTasks(); refreshQueue();
  try {
    const c = loadConfig();
    // Try to upload image; if cache was evicted, write records without image
    let fileToken = null;
    const imgData = await getTaskImageData(taskId, task.fileName);
    if (imgData) {
      try { fileToken = await feishuUploadImage(imgData.file, c.appToken); } catch (_) {}
    }
    const records = task.cards.map(card => {
      const r = {
        'å§“å': (card.name||'').trim(),
        'ç”µè¯': formatPhone(card.phone),
        'å…¬å¸': (card.company||'').trim(),
        'èŒä½': (card.title||'').trim(),
        'é‚®ç®±': (card.email||'').trim(),
        'åœ°å€': (card.address||'').trim(),
      };
      if (fileToken) r['æ¥æºå›¾ç‰‡'] = [{file_token: fileToken}];
      return r;
    });
    await feishuAddRecords(c.appToken, c.tableId, records);
    task.status = 'completed';
    task.error = null;
    deleteImageData(taskId).catch(() => {});
    toast(fileToken ? 'é‡è¯•å†™å…¥æˆåŠŸ' : 'å†™å…¥æˆåŠŸï¼ˆå›¾ç‰‡ç¼“å­˜å·²æ¸…ç†ï¼Œæœªé™„å›¾ï¼‰', 'ok');
  } catch (e) {
    task.status = 'failed';
    task.error = e.message;
    task.errorRaw = e.rawDetail || e.message;
    toast('é‡è¯•å¤±è´¥: ' + e.message, 'err');
  }
  const t2 = loadTasks(); Object.assign(t2.find(t=>t.id===taskId)||{}, task); saveTasks(t2); renderTasks(); refreshQueue();
}

async function retryAll(taskId) {
  const tasks = loadTasks();
  const task = tasks.find(t => t.id === taskId);
  if (!task) { toast('ä»»åŠ¡ä¸å­˜åœ¨', 'err'); return; }
  const imgData = await getTaskImageData(taskId, task.fileName);
  if (!imgData) { toast('å›¾ç‰‡ç¼“å­˜å·²æ¸…ç†ï¼Œè¯·å…ˆç‚¹"é‡æ–°é€‰æ‹©æ–‡ä»¶"', 'err'); return; }
  task.status = 'processing';
  task.error = null;
  task.cards = null;
  saveTasks(tasks); renderTasks(); refreshQueue();
  try {
    const { base64, file } = imgData;

    // 1. AI recognition
    const cards = await callGemini(base64);
    task.cards = cards;
    task.status = 'uploading';
    const t2 = loadTasks(); Object.assign(t2.find(t=>t.id===taskId)||{}, task); saveTasks(t2); renderTasks(); refreshQueue();

    // 2. Upload + write to Feishu
    const c = loadConfig();
    const fileToken = await feishuUploadImage(file, c.appToken);
    const records = cards.map(card => ({
      'å§“å': (card.name||'').trim(),
      'ç”µè¯': formatPhone(card.phone),
      'å…¬å¸': (card.company||'').trim(),
      'èŒä½': (card.title||'').trim(),
      'é‚®ç®±': (card.email||'').trim(),
      'åœ°å€': (card.address||'').trim(),
      'æ¥æºå›¾ç‰‡': [{file_token: fileToken}],
    }));
    await feishuAddRecords(c.appToken, c.tableId, records);
    task.status = 'completed';
    task.error = null;
    deleteImageData(taskId).catch(() => {});
    toast('é‡è¯•æˆåŠŸ', 'ok');
  } catch (e) {
    task.status = 'failed';
    task.error = e.message || String(e);
    task.errorRaw = e.rawDetail || e.message || String(e);
    toast('é‡è¯•å¤±è´¥: ' + task.error, 'err');
  }
  const t3 = loadTasks(); Object.assign(t3.find(t=>t.id===taskId)||{}, task); saveTasks(t3); renderTasks(); refreshQueue();
}

// å¤šä¸ªç”µè¯å·ç ç”¨æ¢è¡Œåˆ†éš”ï¼ˆæ›¿ä»£é€—å·ï¼‰ï¼Œåœ¨é£ä¹¦æ–‡æœ¬å­—æ®µä¸­æ›´æ¸…æ™°
function formatPhone(raw) {
  if (!raw) return '';
  return raw.split(/[,ï¼Œ\/;ï¼›|]+/).map(s => s.trim()).filter(Boolean).join('\n');
}

function esc(s) { if (!s) return ''; const d = document.createElement('div'); d.textContent = s; return d.innerHTML; }

function copyError(btn) {
  const text = btn.getAttribute('data-err');
  // Use textarea fallback â€” works on HTTP and all mobile browsers
  try {
    const ta = document.createElement('textarea');
    ta.value = text;
    ta.style.cssText = 'position:fixed;left:-9999px;top:0;opacity:0';
    document.body.appendChild(ta);
    ta.focus();
    ta.select();
    // iOS Safari needs setSelectionRange
    ta.setSelectionRange(0, ta.value.length);
    document.execCommand('copy');
    document.body.removeChild(ta);
    toast('æŠ¥é”™ä¿¡æ¯å·²å¤åˆ¶', 'info');
  } catch (e) {
    toast('å¤åˆ¶å¤±è´¥ï¼Œè¯·é•¿æŒ‰æ‰‹åŠ¨å¤åˆ¶', 'err');
  }
}

// ========== åŒé¢åç‰‡æ¨¡å¼ ==========
let dualStaging = { front: [], back: [] }; // [{fileName, dataUrl}]

function toggleDualMode(on) {
  document.getElementById('singleUpload').classList.toggle('hidden', on);
  document.getElementById('dualUpload').classList.toggle('hidden', !on);
  const c = loadConfig();
  c.dualMode = !!on;
  saveConfig(c);
}

function initDualMode() {
  const c = loadConfig();
  const on = !!c.dualMode;
  const toggle = document.getElementById('dualModeToggle');
  if (toggle) toggle.checked = on;
  document.getElementById('singleUpload').classList.toggle('hidden', on);
  document.getElementById('dualUpload').classList.toggle('hidden', !on);
}

async function handleDualFiles(side, files) {
  if (!files || !files.length) return;
  for (const file of files) {
    const dataUrl = await fileToDataUrl(file);
    dualStaging[side].push({ fileName: file.name, dataUrl });
  }
  updateDualUI();
}

function updateDualUI() {
  document.getElementById('frontCount').textContent = `å·²é€‰ ${dualStaging.front.length} å¼ `;
  document.getElementById('backCount').textContent = `å·²é€‰ ${dualStaging.back.length} å¼ `;
  const btn = document.getElementById('dualProcessBtn');
  if (btn) btn.disabled = !(dualStaging.front.length > 0 && dualStaging.back.length > 0);
}

function clearDualStaging() {
  dualStaging = { front: [], back: [] };
  updateDualUI();
  // é‡ç½® file inputï¼Œç¡®ä¿åŒä¸€æ–‡ä»¶èƒ½å†æ¬¡é€‰æ‹©
  const fi = document.getElementById('dualFrontInput');
  const bi = document.getElementById('dualBackInput');
  if (fi) fi.value = '';
  if (bi) bi.value = '';
  toast('å·²æ¸…ç©º', 'info');
}

// åˆ é™¤æŸä¸ªä»»åŠ¡çš„å…¨éƒ¨å›¾ç‰‡ï¼ˆæ”¯æŒ dual å’Œ singleï¼‰
function deleteTaskImages(task) {
  if (task.type === 'dual') {
    for (let i = 0; i < (task.frontCount || 0); i++) deleteImageData(`${task.id}_f${i}`).catch(() => {});
    for (let i = 0; i < (task.backCount || 0); i++) deleteImageData(`${task.id}_b${i}`).catch(() => {});
  } else {
    deleteImageData(task.id).catch(() => {});
  }
}

// ---- å¯åŠ¨åŒé¢å¤„ç† ----
async function startDualProcess() {
  const c = loadConfig();
  if (!c.appToken || !c.tableId) { toast('è¯·å…ˆè§£æå¤šç»´è¡¨é“¾æ¥å¹¶åˆå§‹åŒ–è¡¨æ ¼', 'err'); toggleSettings(); return; }
  if (!dualStaging.front.length || !dualStaging.back.length) { toast('è¯·åŒæ—¶ä¸Šä¼ æ­£é¢å’ŒèƒŒé¢å›¾ç‰‡', 'err'); return; }

  const taskId = Date.now() + Math.random();
  const frontImages = [...dualStaging.front];
  const backImages = [...dualStaging.back];

  // ä¿å­˜å›¾ç‰‡åˆ° IndexedDB
  for (let i = 0; i < frontImages.length; i++) {
    await saveImageData(`${taskId}_f${i}`, frontImages[i].dataUrl);
  }
  for (let i = 0; i < backImages.length; i++) {
    await saveImageData(`${taskId}_b${i}`, backImages[i].dataUrl);
  }

  // åˆ›å»ºä»»åŠ¡
  const tasks = loadTasks();
  tasks.unshift({
    id: taskId,
    type: 'dual',
    fileName: `åŒé¢å¤„ç† (æ­£${frontImages.length}å¼  + å${backImages.length}å¼ )`,
    status: 'pending',
    frontCount: frontImages.length,
    backCount: backImages.length,
    cards: null,
    error: null,
    errorRaw: null,
    statusDetail: null,
    createdAt: new Date().toLocaleString(),
  });
  saveTasks(tasks);
  renderTasks();
  refreshQueue();
  clearDualStaging();

  // å¼€å§‹å¤„ç†
  processDualTask(taskId);
}

// ---- åŒé¢å¤„ç†ä¸»é€»è¾‘ ----
async function processDualTask(taskId) {
  if (processing) { toast('æœ‰å…¶ä»–ä»»åŠ¡æ­£åœ¨å¤„ç†ï¼Œè¯·ç¨å€™', 'info'); return; }
  processing = true;

  const tasks = loadTasks();
  const task = tasks.find(t => t.id === taskId);
  if (!task) { processing = false; return; }

  task.status = 'processing';
  task.error = null;
  task.statusDetail = 'å‡†å¤‡ä¸­...';
  saveTasks(tasks); renderTasks(); refreshQueue();
  await new Promise(r => setTimeout(r, 50));

  try {
    // 1. è¯†åˆ«æ­£é¢ï¼ˆä¸­æ–‡ï¼‰
    const allFrontCards = [];
    for (let i = 0; i < task.frontCount; i++) {
      updateDualTaskStatus(taskId, `æ­£é¢è¯†åˆ« ${i + 1}/${task.frontCount}`);
      const dataUrl = await getImageData(`${taskId}_f${i}`);
      if (!dataUrl) throw new Error(`æ­£é¢å›¾ç‰‡ ${i + 1} ç¼“å­˜ä¸¢å¤±`);
      const cards = await callGemini(dataUrlToBase64(dataUrl));
      allFrontCards.push(...cards);
    }

    // 2. è¯†åˆ«èƒŒé¢ï¼ˆè‹±æ–‡ï¼‰
    const allBackCards = [];
    for (let i = 0; i < task.backCount; i++) {
      updateDualTaskStatus(taskId, `èƒŒé¢è¯†åˆ« ${i + 1}/${task.backCount}`);
      const dataUrl = await getImageData(`${taskId}_b${i}`);
      if (!dataUrl) throw new Error(`èƒŒé¢å›¾ç‰‡ ${i + 1} ç¼“å­˜ä¸¢å¤±`);
      const cards = await callGemini(dataUrlToBase64(dataUrl));
      allBackCards.push(...cards);
    }

    // 3. åŒ¹é… + åˆå¹¶
    updateDualTaskStatus(taskId, 'åŒ¹é…åˆå¹¶ä¸­...');
    const mergedCards = matchAndMergeCards(allFrontCards, allBackCards);

    // æ›´æ–° task
    const t2 = loadTasks(); const task2 = t2.find(x => x.id === taskId);
    task2.cards = mergedCards;
    task2.status = 'uploading';
    task2.statusDetail = 'å†™å…¥é£ä¹¦ä¸­...';
    saveTasks(t2); renderTasks(); refreshQueue();
    await new Promise(r => setTimeout(r, 50));

    // 4. ä¸Šä¼ å›¾ç‰‡ + å†™å…¥é£ä¹¦
    const cfg = loadConfig();
    const fileTokens = [];
    // ä¸Šä¼ æ­£é¢ç¬¬ä¸€å¼ å’ŒèƒŒé¢ç¬¬ä¸€å¼ ä½œä¸ºæ¥æºå›¾ç‰‡
    for (const key of [`${taskId}_f0`, `${taskId}_b0`]) {
      const du = await getImageData(key);
      if (du) {
        const file = dataUrlToFile(du, key.includes('_f') ? 'front.jpg' : 'back.jpg');
        try { fileTokens.push(await feishuUploadImage(file, cfg.appToken)); } catch (_) {}
      }
    }
    const attachment = fileTokens.map(ft => ({ file_token: ft }));
    const records = mergedCards.map(card => {
      const r = {
        'å§“å': (card.name || '').trim(),
        'ç”µè¯': (card.phone || '').trim(),
        'å…¬å¸': (card.company || '').trim(),
        'èŒä½': (card.title || '').trim(),
        'é‚®ç®±': (card.email || '').trim(),
        'åœ°å€': (card.address || '').trim(),
      };
      if (attachment.length) r['æ¥æºå›¾ç‰‡'] = attachment;
      return r;
    });
    await feishuAddRecords(cfg.appToken, cfg.tableId, records);

    // 5. å®Œæˆ
    const t3 = loadTasks(); const task3 = t3.find(x => x.id === taskId);
    task3.status = 'completed';
    task3.error = null;
    task3.statusDetail = null;
    saveTasks(t3); renderTasks(); refreshQueue();
    deleteTaskImages(task3);
    toast(`åŒé¢å¤„ç†å®Œæˆï¼Œå…± ${mergedCards.length} å¼ åç‰‡`, 'ok');

  } catch (e) {
    const t3 = loadTasks(); const task3 = t3.find(x => x.id === taskId);
    if (task3) {
      task3.status = 'failed';
      task3.error = e.message || String(e);
      task3.errorRaw = e.rawDetail || e.message || String(e);
      task3.statusDetail = null;
      saveTasks(t3); renderTasks(); refreshQueue();
    }
    toast('åŒé¢å¤„ç†å¤±è´¥: ' + e.message, 'err');
  }

  processing = false;
  processQueue(); // ç»§ç»­å¤„ç†å•é¢é˜Ÿåˆ—ä¸­çš„ä»»åŠ¡
}

function updateDualTaskStatus(taskId, detail) {
  const t = loadTasks();
  const tt = t.find(x => x.id === taskId);
  if (tt) { tt.statusDetail = detail; saveTasks(t); renderTasks(); }
}

// ---- åŒé¢ä»»åŠ¡é‡è¯• ----
async function retryDual(taskId) {
  const tasks = loadTasks();
  const task = tasks.find(t => t.id === taskId);
  if (!task) { toast('ä»»åŠ¡ä¸å­˜åœ¨', 'err'); return; }
  task.status = 'pending';
  task.error = null;
  task.errorRaw = null;
  task.cards = null;
  task.statusDetail = null;
  saveTasks(tasks); renderTasks(); refreshQueue();
  processDualTask(taskId);
}

async function retryDualWrite(taskId) {
  const tasks = loadTasks();
  const task = tasks.find(t => t.id === taskId);
  if (!task || !task.cards || !task.cards.length) { toast('æ— å¯é‡è¯•æ•°æ®', 'err'); return; }
  task.status = 'uploading';
  task.error = null;
  task.statusDetail = 'é‡æ–°å†™å…¥é£ä¹¦ä¸­...';
  saveTasks(tasks); renderTasks(); refreshQueue();
  try {
    const cfg = loadConfig();
    const fileTokens = [];
    for (const key of [`${taskId}_f0`, `${taskId}_b0`]) {
      const du = await getImageData(key);
      if (du) {
        const file = dataUrlToFile(du, key.includes('_f') ? 'front.jpg' : 'back.jpg');
        try { fileTokens.push(await feishuUploadImage(file, cfg.appToken)); } catch (_) {}
      }
    }
    const attachment = fileTokens.map(ft => ({ file_token: ft }));
    const records = task.cards.map(card => {
      const r = {
        'å§“å': (card.name || '').trim(),
        'ç”µè¯': (card.phone || '').trim(),
        'å…¬å¸': (card.company || '').trim(),
        'èŒä½': (card.title || '').trim(),
        'é‚®ç®±': (card.email || '').trim(),
        'åœ°å€': (card.address || '').trim(),
      };
      if (attachment.length) r['æ¥æºå›¾ç‰‡'] = attachment;
      return r;
    });
    await feishuAddRecords(cfg.appToken, cfg.tableId, records);
    task.status = 'completed';
    task.error = null;
    task.statusDetail = null;
    deleteTaskImages(task);
    toast('å†™å…¥æˆåŠŸ', 'ok');
  } catch (e) {
    task.status = 'failed';
    task.error = e.message;
    task.errorRaw = e.rawDetail || e.message;
    task.statusDetail = null;
    toast('å†™å…¥å¤±è´¥: ' + e.message, 'err');
  }
  const t2 = loadTasks(); Object.assign(t2.find(t => t.id === taskId) || {}, task); saveTasks(t2); renderTasks(); refreshQueue();
}

// ========== åç‰‡åŒ¹é… & åˆå¹¶ ==========
function normalizeForMatch(s) {
  return (s || '').replace(/[\s\-\(\)ï¼ˆï¼‰+\u3000Â·.ã€‚]+/g, '').toLowerCase();
}

function matchAndMergeCards(frontCards, backCards) {
  const usedBack = new Set();
  const result = [];

  for (const fc of frontCards) {
    const fcPhone = normalizeForMatch(fc.phone);
    const fcEmail = normalizeForMatch(fc.email);
    let bestIdx = -1;

    for (let j = 0; j < backCards.length; j++) {
      if (usedBack.has(j)) continue;
      const bc = backCards[j];
      // åŒ¹é…ä¼˜å…ˆçº§ï¼šç”µè¯ > é‚®ç®±
      if (fcPhone && normalizeForMatch(bc.phone) && fcPhone === normalizeForMatch(bc.phone)) { bestIdx = j; break; }
      if (fcEmail && normalizeForMatch(bc.email) && fcEmail === normalizeForMatch(bc.email)) { bestIdx = j; break; }
    }

    if (bestIdx >= 0) {
      result.push(mergeCardPair(fc, backCards[bestIdx]));
      usedBack.add(bestIdx);
    } else {
      result.push(fc); // æœªåŒ¹é…çš„æ­£é¢åç‰‡
    }
  }

  // æœªåŒ¹é…çš„èƒŒé¢åç‰‡
  for (let j = 0; j < backCards.length; j++) {
    if (!usedBack.has(j)) result.push(backCards[j]);
  }

  console.log(`[matchAndMerge] æ­£é¢${frontCards.length}å¼  + èƒŒé¢${backCards.length}å¼  â†’ åˆå¹¶å${result.length}å¼  (åŒ¹é…${usedBack.size}å¯¹)`);
  return result;
}

function mergeCardPair(zhCard, enCard) {
  return {
    name: mergeField(zhCard.name, enCard.name),
    phone: (zhCard.phone || enCard.phone || '').trim(),   // ç”µè¯å–éç©ºï¼ˆä¸¤é¢åº”ç›¸åŒï¼‰
    company: mergeField(zhCard.company, enCard.company),
    title: mergeField(zhCard.title, enCard.title),
    email: (zhCard.email || enCard.email || '').trim(),    // é‚®ç®±å–éç©º
    address: mergeField(zhCard.address, enCard.address),
    remark: mergeField(zhCard.remark, enCard.remark),
  };
}

/**
 * æ™ºèƒ½åˆå¹¶ä¸­è‹±æ–‡å­—æ®µï¼š
 * - éƒ½ç©º â†’ ç©º
 * - ä¸€æ–¹ç©º â†’ å–éç©º
 * - å®Œå…¨ç›¸åŒï¼ˆå«å¿½ç•¥å¤§å°å†™ï¼‰â†’ ä¸é‡å¤
 * - ä¸€æ–¹åŒ…å«å¦ä¸€æ–¹ â†’ å–è¾ƒé•¿çš„
 * - ä¸€ä¸ªä¸­æ–‡ä¸€ä¸ªè‹±æ–‡ â†’ "ä¸­æ–‡ï¼ˆEnglishï¼‰"
 * - æ— æ³•åŒºåˆ† â†’ "Aï¼ˆBï¼‰"
 */
function mergeField(val1, val2) {
  const a = (val1 || '').trim();
  const b = (val2 || '').trim();
  if (!a && !b) return '';
  if (!a) return b;
  if (!b) return a;
  if (a === b) return a;
  if (a.toLowerCase() === b.toLowerCase()) return a;
  // ä¸€æ–¹åŒ…å«å¦ä¸€æ–¹
  if (a.includes(b) || b.includes(a)) return a.length >= b.length ? a : b;
  // åˆ¤æ–­ä¸­è‹±æ–‡
  const hasChinese = s => /[\u4e00-\u9fff]/.test(s);
  const aCn = hasChinese(a), bCn = hasChinese(b);
  if (aCn && !bCn) return `${a}ï¼ˆ${b}ï¼‰`;
  if (!aCn && bCn) return `${b}ï¼ˆ${a}ï¼‰`;
  // éƒ½æœ‰ä¸­æ–‡æˆ–éƒ½æ²¡æœ‰ â†’ æ‹¼æ¥ï¼ˆç¬¬ä¸€ä¸ªé€šå¸¸æ˜¯æ­£é¢/ä¸­æ–‡ï¼‰
  return `${a}ï¼ˆ${b}ï¼‰`;
}

// ========== Init ==========
loadSettingsUI();
initModelSelector();
initDualMode();
renderTasks();
refreshQueue();
</script>
</body>
</html>
