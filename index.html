<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
<title>åç‰‡æ‰«æåŠ©æ‰‹</title>
<style>
:root{--primary:#4f46e5;--primary-light:#eef2ff;--danger:#ef4444;--success:#22c55e;--warn:#f59e0b;--bg:#f8fafc;--card:#fff;--border:#e2e8f0;--text:#1e293b;--text2:#64748b;--radius:12px}
*{margin:0;padding:0;box-sizing:border-box}
body{font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,sans-serif;background:var(--bg);color:var(--text);min-height:100vh}
.container{max-width:640px;margin:0 auto;padding:16px}
h1{font-size:22px;text-align:center;padding:16px 0 8px;display:flex;align-items:center;justify-content:center;gap:8px}
.card{background:var(--card);border-radius:var(--radius);padding:16px;margin-bottom:12px;box-shadow:0 1px 3px rgba(0,0,0,.06)}
.card-title{font-size:14px;font-weight:600;margin-bottom:10px;color:var(--text2)}
.banner{background:linear-gradient(135deg,#6366f1,#8b5cf6);color:#fff;border-radius:var(--radius);padding:20px;margin-bottom:16px;text-align:center}
.banner h2{font-size:18px;margin-bottom:6px}
.banner p{font-size:13px;opacity:.85}
label{display:block;font-size:13px;font-weight:500;margin-bottom:4px;color:var(--text2)}
input[type=text],input[type=password],select,textarea{width:100%;padding:8px 12px;border:1px solid var(--border);border-radius:8px;font-size:14px;outline:none;transition:border .2s}
input:focus,select:focus{border-color:var(--primary)}
.row{display:flex;gap:8px;align-items:flex-end}
.row>*:first-child{flex:1}
.btn{display:inline-flex;align-items:center;justify-content:center;gap:6px;padding:10px 20px;border:none;border-radius:8px;font-size:14px;font-weight:500;cursor:pointer;transition:all .15s}
.btn-primary{background:var(--primary);color:#fff}
.btn-primary:hover{background:#4338ca}
.btn-primary:disabled{background:#a5b4fc;cursor:not-allowed}
.btn-outline{background:#fff;color:var(--primary);border:1.5px solid var(--primary)}
.btn-outline:hover{background:var(--primary-light)}
.btn-danger{background:var(--danger);color:#fff}
.btn-sm{padding:6px 12px;font-size:12px}
.btn-block{width:100%}
.btn-lg{padding:14px 24px;font-size:16px}
.status-bar{display:flex;flex-wrap:wrap;gap:6px;margin-bottom:8px}
.chip{display:inline-block;padding:4px 10px;border-radius:20px;font-size:12px;font-weight:500}
.chip-ok{background:#dcfce7;color:#166534}
.chip-warn{background:#fef3c7;color:#92400e}
.chip-err{background:#fee2e2;color:#991b1b}
.chip-info{background:#e0e7ff;color:#3730a3}
.progress-bar{width:100%;height:6px;background:#e2e8f0;border-radius:3px;overflow:hidden;margin:8px 0}
.progress-bar-inner{height:100%;background:var(--primary);transition:width .3s}
.upload-area{border:2px dashed var(--border);border-radius:var(--radius);padding:32px;text-align:center;cursor:pointer;transition:border .2s}
.upload-area:hover{border-color:var(--primary)}
.upload-area.dragging{border-color:var(--primary);background:var(--primary-light)}
.upload-area p{color:var(--text2);font-size:14px;margin-top:8px}
.upload-area .icon{font-size:40px}
.task-item{border:1px solid var(--border);border-radius:8px;padding:12px;margin-bottom:8px}
.task-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:6px}
.task-status{font-size:12px;font-weight:600}
.task-details{margin-top:6px}
.task-details summary{font-size:12px;color:var(--primary);cursor:pointer;user-select:none;padding:4px 0;font-weight:500}
.task-details summary:hover{text-decoration:underline}
.task-cards{overflow-x:auto;margin-top:6px}
.task-cards table{width:100%;border-collapse:collapse;font-size:12px;min-width:500px}
.task-cards th,.task-cards td{padding:6px 8px;border:1px solid var(--border);text-align:left;white-space:nowrap}
.task-cards th{background:var(--primary-light);font-weight:600}
.task-error{color:var(--danger);font-size:12px;margin-top:6px;word-break:break-all}
.hidden{display:none!important}
.tabs{display:flex;gap:4px;margin-bottom:12px}
.tab{padding:8px 16px;border-radius:8px;cursor:pointer;font-size:13px;font-weight:500;background:#f1f5f9;color:var(--text2)}
.tab.active{background:var(--primary);color:#fff}
.settings-toggle{text-align:right;margin-bottom:8px}
.settings-toggle a{font-size:13px;color:var(--primary);cursor:pointer;text-decoration:none}
.fade-in{animation:fadeIn .3s ease-in}
@keyframes fadeIn{from{opacity:0;transform:translateY(8px)}to{opacity:1;transform:none}}
.toast{position:fixed;top:20px;left:50%;transform:translateX(-50%);padding:10px 24px;border-radius:8px;font-size:14px;color:#fff;z-index:9999;opacity:0;transition:opacity .3s}
.toast.show{opacity:1}
.toast-ok{background:#22c55e}
.toast-err{background:#ef4444}
.toast-info{background:#6366f1}
.flex-center{display:flex;align-items:center;gap:8px}
@media(max-width:480px){.container{padding:10px}}
</style>
</head>
<body>
<div class="container">
  <h1>ğŸ“‡ åç‰‡æ‰«æåŠ©æ‰‹</h1>

  <!-- Banner -->
  <div class="banner">
    <h2>é«˜æ•ˆå½•å…¥åç‰‡</h2>
    <p>æ‹ç…§/ä¸Šä¼  â†’ AI è¯†åˆ« â†’ è‡ªåŠ¨å†™å…¥é£ä¹¦å¤šç»´è¡¨</p>
  </div>

  <!-- Status -->
  <div class="card" id="statusCard">
    <div class="status-bar" id="statusBar"></div>
  </div>

  <!-- Settings Toggle -->
  <div class="settings-toggle">
    <a onclick="toggleSettings()">âš™ï¸ é…ç½®è®¾ç½®</a>
  </div>

  <!-- Settings Panel -->
  <div class="card hidden" id="settingsPanel">
    <div class="card-title">é£ä¹¦å¤šç»´è¡¨é…ç½®</div>
    <div style="margin-bottom:12px">
      <label>å¤šç»´è¡¨é“¾æ¥</label>
      <div class="row">
        <input type="text" id="bitableUrl" placeholder="https://...feishu.cn/base/...">
        <button class="btn btn-outline btn-sm" onclick="parseBitableUrl()">è§£æ</button>
      </div>
      <div style="font-size:12px;color:var(--text2);margin-top:4px">
        App Token: <span id="dispAppToken">æœªé…ç½®</span> &nbsp;|&nbsp; Table ID: <span id="dispTableId">æœªé…ç½®</span>
      </div>
    </div>
    <div style="margin-bottom:8px">
      <button class="btn btn-outline btn-sm" onclick="initBitableTable()">åˆå§‹åŒ–åç‰‡è¡¨æ ¼</button>
    </div>
  </div>

  <!-- Upload Area -->
  <div class="card">
    <div class="upload-area" id="uploadArea" onclick="document.getElementById('galleryInput').click()">
      <div class="icon">ğŸ“¸</div>
      <p>ç‚¹å‡»ä¸Šä¼ åç‰‡ç…§ç‰‡ï¼Œæˆ–æ‹–æ‹½åˆ°æ­¤å¤„</p>
      <p style="font-size:12px;color:#94a3b8">æ”¯æŒ JPG / PNG / HEICï¼Œå¯å¤šé€‰</p>
    </div>
    <!-- æ‹ç…§ï¼ˆiOS ç›´æ¥æ‰“å¼€ç›¸æœºï¼‰ -->
    <input type="file" id="cameraInput" accept="image/*" capture="environment" class="hidden" onchange="handleFiles(this.files)">
    <!-- ç›¸å†Œé€‰æ‹©ï¼ˆä¸å¸¦ captureï¼ŒiOS å¼¹å‡ºç›¸å†Œï¼‰ -->
    <input type="file" id="galleryInput" accept="image/*" multiple class="hidden" onchange="handleFiles(this.files)">
    <div style="display:flex;gap:8px;margin-top:8px">
      <button class="btn btn-primary btn-lg" style="flex:1" onclick="document.getElementById('cameraInput').click()">
        ğŸ“· æ‹ç…§
      </button>
      <button class="btn btn-outline btn-lg" style="flex:1" onclick="document.getElementById('galleryInput').click()">
        ğŸ–¼ï¸ ä»ç›¸å†Œé€‰æ‹©
      </button>
    </div>
  </div>

  <!-- Queue Stats -->
  <div class="card" id="queueCard">
    <div class="card-title">è¯†åˆ«é˜Ÿåˆ—</div>
    <div class="progress-bar"><div class="progress-bar-inner" id="progressBar" style="width:0%"></div></div>
    <div style="font-size:13px;color:var(--text2)" id="queueStats">å½“å‰æ— ä»»åŠ¡</div>
  </div>

  <!-- Task List -->
  <div class="card">
    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
      <div class="card-title" style="margin:0">è¯†åˆ«ç»“æœ</div>
      <div style="position:relative;display:inline-block" id="clearDropdown">
        <button class="btn btn-danger btn-sm" onclick="toggleClearMenu()">æ¸…ç† â–¾</button>
        <div id="clearMenu" class="hidden" style="position:absolute;right:0;top:100%;margin-top:4px;background:#fff;border:1px solid var(--border);border-radius:8px;box-shadow:0 4px 12px rgba(0,0,0,.12);z-index:100;min-width:140px;padding:4px 0">
          <div style="padding:8px 14px;font-size:13px;cursor:pointer;white-space:nowrap" onclick="clearByStatus('failed')" onmouseover="this.style.background='#f1f5f9'" onmouseout="this.style.background=''">æ¸…ç†å¤±è´¥ä»»åŠ¡</div>
          <div style="padding:8px 14px;font-size:13px;cursor:pointer;white-space:nowrap" onclick="clearByStatus('completed')" onmouseover="this.style.background='#f1f5f9'" onmouseout="this.style.background=''">æ¸…ç†å·²å®Œæˆ</div>
          <div style="padding:8px 14px;font-size:13px;cursor:pointer;white-space:nowrap" onclick="clearByStatus('pending')" onmouseover="this.style.background='#f1f5f9'" onmouseout="this.style.background=''">æ¸…ç†æ’é˜Ÿä¸­</div>
          <div style="border-top:1px solid var(--border);margin:4px 0"></div>
          <div style="padding:8px 14px;font-size:13px;cursor:pointer;white-space:nowrap;color:var(--danger)" onclick="clearByStatus('all')" onmouseover="this.style.background='#fee2e2'" onmouseout="this.style.background=''">æ¸…ç©ºå…¨éƒ¨</div>
        </div>
      </div>
    </div>
    <div class="tabs" id="filterTabs">
      <div class="tab active" onclick="setFilter('all')">å…¨éƒ¨</div>
      <div class="tab" onclick="setFilter('failed')">å¤±è´¥</div>
      <div class="tab" onclick="setFilter('completed')">å·²å®Œæˆ</div>
    </div>
    <div id="taskList"><div style="text-align:center;color:var(--text2);padding:20px;font-size:14px">æš‚æ— è¯†åˆ«è®°å½•</div></div>
  </div>

  <!-- Guide -->
  <div class="card">
    <div class="card-title">ä½¿ç”¨æŒ‡å¼•</div>
    <ol style="font-size:13px;color:var(--text2);padding-left:20px;line-height:1.8">
      <li>ç‚¹å‡»"é…ç½®è®¾ç½®"ï¼Œç²˜è´´å¤šç»´è¡¨é“¾æ¥å¹¶è§£æ</li>
      <li>ç‚¹å‡»"åˆå§‹åŒ–åç‰‡è¡¨æ ¼"åˆ›å»ºå­—æ®µï¼ˆé¦–æ¬¡ä½¿ç”¨ï¼‰</li>
      <li>ä¸Šä¼ æˆ–æ‹ç…§åç‰‡å›¾ç‰‡</li>
      <li>è‡ªåŠ¨è¯†åˆ«å¹¶å†™å…¥é£ä¹¦å¤šç»´è¡¨</li>
    </ol>
  </div>
</div>

<!-- Toast -->
<div class="toast" id="toast"></div>

<script>
// ========== Config & Storage ==========
const STORAGE_KEY = 'card_scanner_config';
const TASKS_KEY = 'card_scanner_tasks';

// Credentials are injected server-side â€” NOT exposed in frontend code
const FIXED_AIHUB_ENV = 'prod';
const FIXED_MODEL_ID = 'gemini-3-pro-preview';

// When running via local proxy (server.js), API calls go through /api/... to avoid CORS.
const PROXY_BASE = location.protocol === 'file:' ? '' : '';
const FEISHU_BASE = '/api/feishu/';
const ENV_URLS = {
  prod: '/api/aihub-prod/',
  pre: '/api/aihub-pre/',
  test: '/api/aihub-test/',
};

function loadConfig() {
  let cfg;
  try { cfg = JSON.parse(localStorage.getItem(STORAGE_KEY)) || {}; } catch { cfg = {}; }
  cfg.aihubEnv = FIXED_AIHUB_ENV;
  cfg.modelId = FIXED_MODEL_ID;
  return cfg;
}
function saveConfig(cfg) { localStorage.setItem(STORAGE_KEY, JSON.stringify(cfg)); }
function loadTasks() {
  try { return JSON.parse(localStorage.getItem(TASKS_KEY)) || []; } catch { return []; }
}
function saveTasks(tasks) { localStorage.setItem(TASKS_KEY, JSON.stringify(tasks)); }

// ========== Toast ==========
function toast(msg, type = 'info') {
  const el = document.getElementById('toast');
  el.textContent = msg;
  el.className = 'toast show toast-' + type;
  setTimeout(() => el.classList.remove('show'), 3000);
}

// ========== Settings UI ==========
function toggleSettings() {
  const p = document.getElementById('settingsPanel');
  p.classList.toggle('hidden');
}

function loadSettingsUI() {
  const c = loadConfig();
  document.getElementById('bitableUrl').value = '';
  document.getElementById('dispAppToken').textContent = c.appToken || 'æœªé…ç½®';
  document.getElementById('dispTableId').textContent = c.tableId || 'æœªé…ç½®';
  refreshStatus();
}

function parseBitableUrl() {
  const url = document.getElementById('bitableUrl').value.trim();
  if (!url) { toast('è¯·å…ˆç²˜è´´é“¾æ¥', 'err'); return; }
  try {
    const u = new URL(url);
    const segs = u.pathname.split('/');
    const baseIdx = segs.indexOf('base');
    const appToken = baseIdx >= 0 && baseIdx + 1 < segs.length ? segs[baseIdx + 1] : null;
    const tableId = u.searchParams.get('table') || '';
    if (!appToken) throw new Error('æ— æ³•æå– App Token');
    const c = loadConfig();
    c.appToken = appToken;
    c.tableId = tableId;
    saveConfig(c);
    document.getElementById('dispAppToken').textContent = appToken;
    document.getElementById('dispTableId').textContent = tableId || 'æœªæ£€æµ‹åˆ°';
    refreshStatus();
    toast(`è§£ææˆåŠŸ! App Token: ${appToken}`, 'ok');
  } catch (e) {
    toast('è§£æå¤±è´¥: ' + e.message, 'err');
  }
}

// ========== Status ==========
function refreshStatus() {
  const c = loadConfig();
  const bar = document.getElementById('statusBar');
  const items = [];
  items.push({t:'é£ä¹¦å‡­è¯ âœ“ (æœåŠ¡ç«¯)',cls:'chip-ok'});
  items.push({t:'AI Key âœ“ (æœåŠ¡ç«¯)',cls:'chip-ok'});
  items.push(c.appToken && c.tableId ? {t:'å¤šç»´è¡¨ âœ“',cls:'chip-ok'} : {t:'å¤šç»´è¡¨ âœ—',cls:'chip-warn'});
  items.push({t:'ç¯å¢ƒ: ç”Ÿäº§', cls:'chip-info'});
  bar.innerHTML = items.map(i => `<span class="chip ${i.cls}">${i.t}</span>`).join('');
}

// ========== Feishu API ==========
let tenantToken = null;
let tenantTokenExpire = 0;

async function ensureTenantToken(forceRefresh = false) {
  const now = Date.now() / 1000;
  if (!forceRefresh && tenantToken && now < tenantTokenExpire) return;
  // Call server-side endpoint â€” credentials never leave the server
  const resp = await fetch('/api/internal/tenant-token', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json; charset=utf-8' },
  });
  const data = await resp.json();
  if (data.code !== 0) throw new Error('è·å– tenant_token å¤±è´¥: ' + JSON.stringify(data));
  tenantToken = data.tenant_access_token;
  tenantTokenExpire = now + (data.expire || 7200) - 120;
}

async function feishuPost(url, body, isFormData = false) {
  await ensureTenantToken();
  const headers = { 'Authorization': 'Bearer ' + tenantToken };
  if (!isFormData) headers['Content-Type'] = 'application/json; charset=utf-8';
  let resp = await fetch(url, {method:'POST', headers, body: isFormData ? body : JSON.stringify(body)});
  if (resp.status === 401) {
    await ensureTenantToken(true);
    headers['Authorization'] = 'Bearer ' + tenantToken;
    resp = await fetch(url, {method:'POST', headers, body: isFormData ? body : JSON.stringify(body)});
  }
  const data = await resp.json();
  if (!resp.ok && resp.status >= 400) throw new Error(`Feishu HTTP ${resp.status}: ${JSON.stringify(data).slice(0,500)}`);
  return data;
}

async function feishuUploadImage(file, parentNode) {
  await ensureTenantToken();
  const fd = new FormData();
  fd.append('file_name', file.name);
  fd.append('parent_type', 'bitable_image');
  fd.append('parent_node', parentNode);
  fd.append('size', file.size);
  fd.append('file', file);
  const data = await feishuPost(FEISHU_BASE + 'drive/v1/medias/upload_all', fd, true);
  if (data.code === 0) return data.data.file_token;
  throw new Error('ä¸Šä¼ å›¾ç‰‡å¤±è´¥: ' + JSON.stringify(data));
}

async function feishuAddRecords(appToken, tableId, records) {
  const data = await feishuPost(
    `${FEISHU_BASE}bitable/v1/apps/${appToken}/tables/${tableId}/records/batch_create`,
    { records: records.map(r => ({ fields: r })) }
  );
  if (data.code === 0) return data.data.records.map(r => r.record_id);
  throw new Error('å†™å…¥è®°å½•å¤±è´¥: ' + JSON.stringify(data));
}

async function initBitableTable() {
  const c = loadConfig();
  if (!c.appToken) { toast('è¯·å…ˆè§£æå¤šç»´è¡¨é“¾æ¥', 'err'); return; }
  try {
    const data = await feishuPost(
      `${FEISHU_BASE}bitable/v1/apps/${c.appToken}/tables`,
      { table: {
        name: 'åç‰‡æ•°æ®', default_view_name: 'è¡¨æ ¼è§†å›¾',
        fields: [
          {field_name:'å§“å',type:1,ui_type:'Text'},
          {field_name:'ç”µè¯',type:13,ui_type:'Phone'},
          {field_name:'å…¬å¸',type:1,ui_type:'Text'},
          {field_name:'èŒä½',type:1,ui_type:'Text'},
          {field_name:'é‚®ç®±',type:1,ui_type:'Text'},
          {field_name:'åœ°å€',type:1,ui_type:'Text'},
          {field_name:'å½•å…¥æ—¶é—´',type:1001,ui_type:'CreatedTime'},
          {field_name:'æ¥æºå›¾ç‰‡',type:17,ui_type:'Attachment'},
        ]
      }}
    );
    if (data.code === 0) {
      c.tableId = data.data.table_id;
      saveConfig(c);
      document.getElementById('dispTableId').textContent = c.tableId;
      refreshStatus();
      toast('è¡¨æ ¼åˆå§‹åŒ–æˆåŠŸ! Table ID: ' + c.tableId, 'ok');
    } else {
      throw new Error(JSON.stringify(data));
    }
  } catch (e) { toast('åˆå§‹åŒ–å¤±è´¥: ' + e.message, 'err'); }
}

// ========== Gemini API ==========
async function callGemini(base64Image) {
  const c = loadConfig();
  const env = c.aihubEnv || 'prod';
  const baseUrl = ENV_URLS[env] || ENV_URLS.prod;
  const model = c.modelId || 'gemini-3-pro-preview';
  const url = `${baseUrl}${model}:generateContent`;

  const prompt = `ä½ æ˜¯ä¸€åä¸“ä¸šçš„åç‰‡ç»“æ„åŒ–è§£æå¼•æ“ã€‚è¯·è¯†åˆ«å›¾ç‰‡ä¸­çš„å…¨éƒ¨åç‰‡å¹¶è¾“å‡ºç»“æ„åŒ– JSONã€‚
ä»…è¾“å‡º JSON æ•°ç»„ï¼Œä¸è¦ Markdownï¼Œä¸è¦è§£é‡Šã€‚
å­—æ®µå›ºå®šï¼šname, phone, company, title, email, address, remarkã€‚
ç¼ºå¤±å­—æ®µç”¨ç©ºå­—ç¬¦ä¸²ã€‚`;

  const body = {
    contents: [{ role: 'user', parts: [
      { text: prompt },
      { inlineData: { mimeType: 'image/jpeg', data: base64Image } }
    ]}],
    generationConfig: { temperature: 0.0, maxOutputTokens: 4096 }
  };

  // API-KEY is injected by server proxy â€” not sent from frontend
  const headers = { 'Content-Type': 'application/json' };
  let lastError;
  for (let attempt = 0; attempt < 3; attempt++) {
    try {
      const resp = await fetch(url, { method:'POST', headers, body: JSON.stringify(body) });
      // HTTP-level errors: fail fast, no retry
      if (!resp.ok) {
        const errText = await resp.text().catch(() => '');
        let msg = `AI æœåŠ¡ HTTP ${resp.status}: ${errText.slice(0, 200)}`;
        if (resp.status === 403) msg = 'AI æœåŠ¡æ‹’ç»è®¿é—® (403)ï¼Œè¯·ç¡®è®¤ç½‘ç»œç¯å¢ƒå¯è®¿é—® AIHub';
        if (resp.status === 401) msg = 'AI æœåŠ¡é‰´æƒå¤±è´¥ (401)ï¼Œè¯·æ£€æŸ¥ API-KEY';
        const err = new Error(msg);
        err._noRetry = true;
        throw err;
      }
      const data = await resp.json();
      const code = data.code;
      if (code === 61100001 || String(code) === '61100001') {
        lastError = new Error('AIHub æš‚æ—¶ä¸å¯ç”¨ï¼Œé‡è¯•ä¸­...');
        await new Promise(r => setTimeout(r, 800 * Math.pow(2, attempt)));
        continue;
      }
      if (code !== undefined && code !== null && code !== 0) throw new Error(`AIHub error: code=${code}, msg=${data.msg}`);

      let candidates = data.candidates || (data.data && data.data.candidates);
      let rawText = extractText(candidates);

      // MAX_TOKENS retry: either no text at all, or finishReason is MAX_TOKENS
      const finishReason = candidates && candidates[0] ? (candidates[0].finishReason || '') : '';
      if (finishReason === 'MAX_TOKENS' || (!rawText && candidates && candidates.length)) {
        body.generationConfig.maxOutputTokens = 8192;
        body.contents[0].parts[0].text = 'è¯†åˆ«å›¾ç‰‡ä¸­æ‰€æœ‰åç‰‡ï¼Œè¿”å› JSON æ•°ç»„ï¼Œæ¯é¡¹åŒ…å« name,phone,company,title,email,address,remarkã€‚ä»…è¾“å‡º JSONï¼Œä¸è¦è§£é‡Šã€‚ç¼ºå¤±å­—æ®µç”¨ç©ºå­—ç¬¦ä¸²ã€‚';
        const resp2 = await fetch(url, { method:'POST', headers, body: JSON.stringify(body) });
        const data2 = await resp2.json();
        const candidates2 = data2.candidates || (data2.data && data2.data.candidates);
        const rawText2 = extractText(candidates2);
        if (rawText2) rawText = rawText2; // prefer retry result if available
      }

      if (!rawText) throw new Error('æ¨¡å‹æœªè¿”å›æ–‡æœ¬å†…å®¹');
      return parseCards(rawText);
    } catch (e) { lastError = e; if (e._noRetry) break; if (attempt < 2) await new Promise(r => setTimeout(r, 800 * Math.pow(2, attempt))); }
  }
  throw lastError;
}

function extractText(candidates) {
  if (!candidates || !candidates.length) return null;
  for (const c of candidates) {
    if (c.content && c.content.parts) {
      for (const p of c.content.parts) {
        if (p.text && p.text.trim()) return p.text;
      }
    }
    if (c.text && c.text.trim()) return c.text;
  }
  return null;
}

function parseCards(rawText) {
  let s = rawText.trim();
  // Strip markdown fences
  if (s.startsWith('```json')) s = s.slice(7);
  else if (s.startsWith('```')) s = s.slice(3);
  if (s.endsWith('```')) s = s.slice(0, -3);
  s = s.trim();

  // Try normal parse first
  try {
    const parsed = JSON.parse(s);
    return Array.isArray(parsed) ? parsed : [parsed];
  } catch (_) { /* fall through to repair */ }

  // Attempt to repair truncated JSON array
  // Strategy: find last complete object "}" before truncation, close the array
  const repaired = repairTruncatedJsonArray(s);
  if (repaired && repaired.length > 0) return repaired;

  throw new Error('JSON è§£æå¤±è´¥ï¼Œæ¨¡å‹è¾“å‡ºå¯èƒ½è¢«æˆªæ–­ã€‚åŸå§‹æ–‡æœ¬å‰200å­—: ' + s.slice(0, 200));
}

function repairTruncatedJsonArray(s) {
  // Ensure it starts with '['
  if (!s.startsWith('[')) {
    // Maybe a single truncated object
    if (s.startsWith('{')) {
      // Try to close the object
      const fixed = tryCloseObject(s);
      if (fixed) return [fixed];
    }
    return null;
  }

  // Find the last complete '}' that ends a valid object boundary
  // Walk backwards to find a good cut point
  for (let i = s.length - 1; i > 0; i--) {
    if (s[i] === '}') {
      const candidate = s.slice(0, i + 1) + ']';
      try {
        const parsed = JSON.parse(candidate);
        if (Array.isArray(parsed) && parsed.length > 0) {
          console.log(`[parseCards] Repaired truncated JSON: kept ${parsed.length} cards, cut at position ${i+1}/${s.length}`);
          return parsed;
        }
      } catch (_) { continue; }
    }
  }
  return null;
}

function tryCloseObject(s) {
  // Try progressively trimming from the end and closing braces
  for (let i = s.length - 1; i > 0; i--) {
    // Find last complete key-value pair
    if (s[i] === '"' || s[i] === ',' || s[i] === '}') {
      // Try closing at various points
      let candidate = s.slice(0, i + 1);
      // Count open/close braces
      const opens = (candidate.match(/\{/g) || []).length;
      const closes = (candidate.match(/\}/g) || []).length;
      candidate += '}'.repeat(Math.max(0, opens - closes));
      try {
        return JSON.parse(candidate);
      } catch (_) { continue; }
    }
  }
  return null;
}

// ========== File Handling & Persistent Image Storage (IndexedDB) ==========
function fileToBase64(file) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = () => {
      const dataUrl = reader.result;
      resolve(dataUrl.split(',')[1]); // strip "data:image/...;base64,"
    };
    reader.onerror = reject;
    reader.readAsDataURL(file);
  });
}

function fileToDataUrl(file) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = () => resolve(reader.result);
    reader.onerror = reject;
    reader.readAsDataURL(file);
  });
}

function dataUrlToBase64(dataUrl) {
  return dataUrl.split(',')[1];
}

function dataUrlToBlob(dataUrl) {
  const parts = dataUrl.split(',');
  const mime = parts[0].match(/:(.*?);/)[1];
  const b64 = atob(parts[1]);
  const arr = new Uint8Array(b64.length);
  for (let i = 0; i < b64.length; i++) arr[i] = b64.charCodeAt(i);
  return new Blob([arr], { type: mime });
}

function dataUrlToFile(dataUrl, fileName) {
  const blob = dataUrlToBlob(dataUrl);
  return new File([blob], fileName, { type: blob.type });
}

// IndexedDB for persistent image storage (survives page refresh)
const IDB_NAME = 'card_scanner_images';
const IDB_STORE = 'images';

function openImageDB() {
  return new Promise((resolve, reject) => {
    const req = indexedDB.open(IDB_NAME, 1);
    req.onupgradeneeded = () => req.result.createObjectStore(IDB_STORE);
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
}

async function saveImageData(taskId, dataUrl) {
  const db = await openImageDB();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(IDB_STORE, 'readwrite');
    tx.objectStore(IDB_STORE).put(dataUrl, String(taskId));
    tx.oncomplete = () => resolve();
    tx.onerror = () => reject(tx.error);
  });
}

async function getImageData(taskId) {
  const db = await openImageDB();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(IDB_STORE, 'readonly');
    const req = tx.objectStore(IDB_STORE).get(String(taskId));
    req.onsuccess = () => resolve(req.result || null);
    req.onerror = () => reject(req.error);
  });
}

async function deleteImageData(taskId) {
  const db = await openImageDB();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(IDB_STORE, 'readwrite');
    tx.objectStore(IDB_STORE).delete(String(taskId));
    tx.oncomplete = () => resolve();
    tx.onerror = () => reject(tx.error);
  });
}

async function clearAllImageData() {
  const db = await openImageDB();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(IDB_STORE, 'readwrite');
    tx.objectStore(IDB_STORE).clear();
    tx.oncomplete = () => resolve();
    tx.onerror = () => reject(tx.error);
  });
}

async function getImageCount() {
  const db = await openImageDB();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(IDB_STORE, 'readonly');
    const req = tx.objectStore(IDB_STORE).count();
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
}

async function getAllImageKeys() {
  const db = await openImageDB();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(IDB_STORE, 'readonly');
    const req = tx.objectStore(IDB_STORE).getAllKeys();
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
}

// Keep at most MAX_CACHED_IMAGES images; evict completed/oldest first
const MAX_CACHED_IMAGES = 30;
async function evictOldImages() {
  const count = await getImageCount();
  if (count <= MAX_CACHED_IMAGES) return;
  const keys = await getAllImageKeys();
  const tasks = loadTasks();
  // Build set of task IDs that still need images (pending/processing/uploading/failed)
  const neededIds = new Set(
    tasks.filter(t => t.status !== 'completed').map(t => String(t.id))
  );
  // Delete images for completed tasks first, then oldest
  const toDelete = keys.filter(k => !neededIds.has(k));
  const extra = count - MAX_CACHED_IMAGES;
  const deleteBatch = toDelete.slice(0, Math.max(extra, 0));
  for (const k of deleteBatch) {
    await deleteImageData(k).catch(() => {});
  }
}

// ========== Drag & Drop ==========
const uploadArea = document.getElementById('uploadArea');
uploadArea.addEventListener('dragover', e => { e.preventDefault(); uploadArea.classList.add('dragging'); });
uploadArea.addEventListener('dragleave', () => uploadArea.classList.remove('dragging'));
uploadArea.addEventListener('drop', e => { e.preventDefault(); uploadArea.classList.remove('dragging'); handleFiles(e.dataTransfer.files); });

// ========== Task Queue ==========
let currentFilter = 'all';
let processing = false;

async function handleFiles(files) {
  if (!files || !files.length) return;
  const c = loadConfig();
  if (!c.appToken || !c.tableId) { toast('è¯·å…ˆè§£æå¤šç»´è¡¨é“¾æ¥å¹¶åˆå§‹åŒ–è¡¨æ ¼', 'err'); toggleSettings(); return; }

  const tasks = loadTasks();
  for (const file of files) {
    const id = Date.now() + Math.random();
    // Read file to dataUrl and persist to IndexedDB immediately
    const dataUrl = await fileToDataUrl(file);
    await saveImageData(id, dataUrl);
    tasks.unshift({
      id,
      fileName: file.name,
      status: 'pending',
      cards: null,
      error: null,
      createdAt: new Date().toLocaleString(),
    });
  }
  saveTasks(tasks);
  renderTasks();
  refreshQueue();
  evictOldImages().catch(() => {}); // auto cleanup
  processQueue();
}

// Helper: get base64 and File object for a task from IndexedDB
// Returns null if image data is no longer available
async function getTaskImageData(taskId, fileName) {
  const dataUrl = await getImageData(taskId);
  if (!dataUrl) return null;
  const base64 = dataUrlToBase64(dataUrl);
  const file = dataUrlToFile(dataUrl, fileName || 'image.jpg');
  return { base64, file };
}

// Let user re-select a file for a task whose image was evicted
function reSelectFile(taskId) {
  const input = document.createElement('input');
  input.type = 'file';
  input.accept = 'image/*';
  input.onchange = async () => {
    const file = input.files[0];
    if (!file) return;
    const dataUrl = await fileToDataUrl(file);
    await saveImageData(taskId, dataUrl);
    toast('æ–‡ä»¶å·²é‡æ–°å…³è”ï¼Œè¯·å†æ¬¡ç‚¹å‡»é‡è¯•', 'ok');
  };
  input.click();
}

async function processQueue() {
  if (processing) return;
  processing = true;
  while (true) {
    const tasks = loadTasks();
    const idx = tasks.findIndex(t => t.status === 'pending');
    if (idx < 0) break;
    const task = tasks[idx];
    task.status = 'processing';
    saveTasks(tasks); renderTasks(); refreshQueue();
    // Yield to browser so UI can repaint before starting network request
    await new Promise(r => setTimeout(r, 50));

    try {
      const imgData = await getTaskImageData(task.id, task.fileName);
      if (!imgData) throw new Error('å›¾ç‰‡ç¼“å­˜å·²æ¸…ç†ï¼Œè¯·ç‚¹å‡»"é‡æ–°é€‰æ‹©æ–‡ä»¶"åé‡è¯•');
      const { base64, file } = imgData;

      const cards = await callGemini(base64);
      task.cards = cards;
      task.status = 'uploading';
      const t2 = loadTasks(); Object.assign(t2.find(t=>t.id===task.id), task); saveTasks(t2); renderTasks(); refreshQueue();
      await new Promise(r => setTimeout(r, 50));

      const c = loadConfig();
      const fileToken = await feishuUploadImage(file, c.appToken);
      const records = cards.map(card => ({
        'å§“å': (card.name||'').trim(),
        'ç”µè¯': (card.phone||'').trim(),
        'å…¬å¸': (card.company||'').trim(),
        'èŒä½': (card.title||'').trim(),
        'é‚®ç®±': (card.email||'').trim(),
        'åœ°å€': (card.address||'').trim(),
        'æ¥æºå›¾ç‰‡': [{file_token: fileToken}],
      }));
      await feishuAddRecords(c.appToken, c.tableId, records);

      task.status = 'completed';
      task.error = null;
      // Clean up stored image for completed tasks to save space
      deleteImageData(task.id).catch(() => {});
    } catch (e) {
      task.status = 'failed';
      task.error = e.message || String(e);
    }
    const t3 = loadTasks(); Object.assign(t3.find(t=>t.id===task.id)||{}, task); saveTasks(t3); renderTasks(); refreshQueue();
  }
  processing = false;
}

function refreshQueue() {
  const tasks = loadTasks();
  const pending = tasks.filter(t=>t.status==='pending').length;
  const proc = tasks.filter(t=>t.status==='processing').length;
  const uploading = tasks.filter(t=>t.status==='uploading').length;
  const completed = tasks.filter(t=>t.status==='completed').length;
  const failed = tasks.filter(t=>t.status==='failed').length;
  const total = tasks.length;
  const pct = total === 0 ? 0 : Math.round(completed / total * 100);
  document.getElementById('progressBar').style.width = pct + '%';
  document.getElementById('queueStats').textContent =
    total === 0 ? 'å½“å‰æ— ä»»åŠ¡' :
    `æ’é˜Ÿ: ${pending}  è¯†åˆ«ä¸­: ${proc}  ä¸Šä¼ ä¸­: ${uploading}  å®Œæˆ: ${completed}  å¤±è´¥: ${failed}`;
}

function setFilter(f) {
  currentFilter = f;
  document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
  document.querySelector(`.tab[onclick="setFilter('${f}')"]`).classList.add('active');
  renderTasks();
}

function toggleClearMenu() {
  document.getElementById('clearMenu').classList.toggle('hidden');
}
// Close menu when clicking outside
document.addEventListener('click', (e) => {
  const dd = document.getElementById('clearDropdown');
  if (dd && !dd.contains(e.target)) {
    document.getElementById('clearMenu').classList.add('hidden');
  }
});

function clearByStatus(status) {
  document.getElementById('clearMenu').classList.add('hidden');
  const labelMap = {failed:'å¤±è´¥',completed:'å·²å®Œæˆ',pending:'æ’é˜Ÿä¸­',all:'å…¨éƒ¨'};
  if (!confirm(`ç¡®è®¤æ¸…ç†ã€Œ${labelMap[status]}ã€ä»»åŠ¡ï¼Ÿ`)) return;
  if (status === 'all') {
    saveTasks([]);
    clearAllImageData().catch(() => {});
  } else {
    const tasks = loadTasks();
    const toRemove = tasks.filter(t => t.status === status);
    const remaining = tasks.filter(t => t.status !== status);
    // Clean images for removed tasks
    toRemove.forEach(t => deleteImageData(t.id).catch(() => {}));
    saveTasks(remaining);
  }
  renderTasks();
  refreshQueue();
  toast(`å·²æ¸…ç†ã€Œ${labelMap[status]}ã€ä»»åŠ¡`, 'ok');
}

function renderTasks() {
  const tasks = loadTasks();
  let filtered = tasks;
  if (currentFilter === 'failed') filtered = tasks.filter(t => t.status === 'failed');
  if (currentFilter === 'completed') filtered = tasks.filter(t => t.status === 'completed');

  const el = document.getElementById('taskList');
  if (!filtered.length) {
    el.innerHTML = '<div style="text-align:center;color:var(--text2);padding:20px;font-size:14px">æš‚æ— è¯†åˆ«è®°å½•</div>';
    return;
  }

  el.innerHTML = filtered.map(task => {
    const statusMap = {pending:'æ’é˜Ÿä¸­',processing:'è¯†åˆ«ä¸­',uploading:'ä¸Šä¼ ä¸­',completed:'å·²å®Œæˆ',failed:'å¤±è´¥'};
    const colorMap = {pending:'var(--warn)',processing:'var(--primary)',uploading:'var(--primary)',completed:'var(--success)',failed:'var(--danger)'};
    const cards = task.cards || [];
    let cardsHtml = '';
    if (cards.length) {
      cardsHtml = `<details class="task-details">
        <summary>æŸ¥çœ‹è¯†åˆ«ç»“æœï¼ˆ${cards.length} å¼ åç‰‡ï¼‰</summary>
        <div class="task-cards"><table>
          <tr><th>å§“å</th><th>å…¬å¸</th><th>èŒä½</th><th>ç”µè¯</th><th>é‚®ç®±</th></tr>
          ${cards.map(c=>`<tr><td>${esc(c.name)}</td><td>${esc(c.company)}</td><td>${esc(c.title)}</td><td>${esc(c.phone)}</td><td>${esc(c.email)}</td></tr>`).join('')}
        </table></div>
      </details>`;
    }
    const errorHtml = task.error ? `<div class="task-error" style="display:flex;align-items:flex-start;gap:6px">
      <span style="flex:1">âŒ ${esc(task.error)}</span>
      <button class="btn btn-sm" style="flex-shrink:0;padding:2px 8px;font-size:11px;background:#fee2e2;color:#991b1b;border:1px solid #fca5a5" onclick="copyError(this)" data-err="${esc(task.error).replace(/"/g,'&quot;')}">å¤åˆ¶</button>
    </div>` : '';
    // Retry buttons: different actions depending on what failed
    let retryHtml = '';
    if (task.status === 'failed') {
      const hasCards = task.cards && task.cards.length;
      // "Re-select file" only needed when retrying recognition (needs image)
      const reselectBtn = `<button class="btn btn-sm" style="background:#f1f5f9;color:var(--text2);border:1px solid var(--border)" onclick="reSelectFile(${task.id})">ğŸ“‚ é‡æ–°é€‰æ‹©æ–‡ä»¶</button>`;
      if (hasCards) {
        // Recognition succeeded, only Feishu write failed â†’ no need to re-select file
        retryHtml = `<div style="display:flex;gap:6px;margin-top:6px;flex-wrap:wrap">
          <button class="btn btn-outline btn-sm" onclick="retryWrite(${task.id})">ğŸ”„ é‡è¯•å†™å…¥é£ä¹¦</button>
          <button class="btn btn-outline btn-sm" onclick="retryAll(${task.id})">ğŸ” é‡æ–°è¯†åˆ«+å†™å…¥</button>
        </div>`;
      } else {
        // Recognition failed â†’ needs image to retry, show re-select button
        retryHtml = `<div style="display:flex;gap:6px;margin-top:6px;flex-wrap:wrap">
          <button class="btn btn-outline btn-sm" onclick="retryAll(${task.id})">ğŸ” é‡æ–°è¯†åˆ«</button>
          ${reselectBtn}
        </div>`;
      }
    }

    return `<div class="task-item fade-in">
      <div class="task-header">
        <span style="font-size:13px;font-weight:500">${esc(task.fileName)}</span>
        <span class="task-status" style="color:${colorMap[task.status]}">${statusMap[task.status]}</span>
      </div>
      <div style="font-size:11px;color:var(--text2)">${task.createdAt} Â· åç‰‡æ•°: ${cards.length}</div>
      ${cardsHtml}${errorHtml}${retryHtml}
    </div>`;
  }).join('');
}

async function retryWrite(taskId) {
  const tasks = loadTasks();
  const task = tasks.find(t => t.id === taskId);
  if (!task || !task.cards || !task.cards.length) { toast('æ— å¯é‡è¯•æ•°æ®', 'err'); return; }
  task.status = 'uploading';
  task.error = null;
  saveTasks(tasks); renderTasks(); refreshQueue();
  try {
    const c = loadConfig();
    // Try to upload image; if cache was evicted, write records without image
    let fileToken = null;
    const imgData = await getTaskImageData(taskId, task.fileName);
    if (imgData) {
      try { fileToken = await feishuUploadImage(imgData.file, c.appToken); } catch (_) {}
    }
    const records = task.cards.map(card => {
      const r = {
        'å§“å': (card.name||'').trim(),
        'ç”µè¯': (card.phone||'').trim(),
        'å…¬å¸': (card.company||'').trim(),
        'èŒä½': (card.title||'').trim(),
        'é‚®ç®±': (card.email||'').trim(),
        'åœ°å€': (card.address||'').trim(),
      };
      if (fileToken) r['æ¥æºå›¾ç‰‡'] = [{file_token: fileToken}];
      return r;
    });
    await feishuAddRecords(c.appToken, c.tableId, records);
    task.status = 'completed';
    task.error = null;
    deleteImageData(taskId).catch(() => {});
    toast(fileToken ? 'é‡è¯•å†™å…¥æˆåŠŸ' : 'å†™å…¥æˆåŠŸï¼ˆå›¾ç‰‡ç¼“å­˜å·²æ¸…ç†ï¼Œæœªé™„å›¾ï¼‰', 'ok');
  } catch (e) {
    task.status = 'failed';
    task.error = e.message;
    toast('é‡è¯•å¤±è´¥: ' + e.message, 'err');
  }
  const t2 = loadTasks(); Object.assign(t2.find(t=>t.id===taskId)||{}, task); saveTasks(t2); renderTasks(); refreshQueue();
}

async function retryAll(taskId) {
  const tasks = loadTasks();
  const task = tasks.find(t => t.id === taskId);
  if (!task) { toast('ä»»åŠ¡ä¸å­˜åœ¨', 'err'); return; }
  const imgData = await getTaskImageData(taskId, task.fileName);
  if (!imgData) { toast('å›¾ç‰‡ç¼“å­˜å·²æ¸…ç†ï¼Œè¯·å…ˆç‚¹"é‡æ–°é€‰æ‹©æ–‡ä»¶"', 'err'); return; }
  task.status = 'processing';
  task.error = null;
  task.cards = null;
  saveTasks(tasks); renderTasks(); refreshQueue();
  try {
    const { base64, file } = imgData;

    // 1. AI recognition
    const cards = await callGemini(base64);
    task.cards = cards;
    task.status = 'uploading';
    const t2 = loadTasks(); Object.assign(t2.find(t=>t.id===taskId)||{}, task); saveTasks(t2); renderTasks(); refreshQueue();

    // 2. Upload + write to Feishu
    const c = loadConfig();
    const fileToken = await feishuUploadImage(file, c.appToken);
    const records = cards.map(card => ({
      'å§“å': (card.name||'').trim(),
      'ç”µè¯': (card.phone||'').trim(),
      'å…¬å¸': (card.company||'').trim(),
      'èŒä½': (card.title||'').trim(),
      'é‚®ç®±': (card.email||'').trim(),
      'åœ°å€': (card.address||'').trim(),
      'æ¥æºå›¾ç‰‡': [{file_token: fileToken}],
    }));
    await feishuAddRecords(c.appToken, c.tableId, records);
    task.status = 'completed';
    task.error = null;
    deleteImageData(taskId).catch(() => {});
    toast('é‡è¯•æˆåŠŸ', 'ok');
  } catch (e) {
    task.status = 'failed';
    task.error = e.message || String(e);
    toast('é‡è¯•å¤±è´¥: ' + task.error, 'err');
  }
  const t3 = loadTasks(); Object.assign(t3.find(t=>t.id===taskId)||{}, task); saveTasks(t3); renderTasks(); refreshQueue();
}

function esc(s) { if (!s) return ''; const d = document.createElement('div'); d.textContent = s; return d.innerHTML; }

function copyError(btn) {
  const text = btn.getAttribute('data-err');
  // Use textarea fallback â€” works on HTTP and all mobile browsers
  try {
    const ta = document.createElement('textarea');
    ta.value = text;
    ta.style.cssText = 'position:fixed;left:-9999px;top:0;opacity:0';
    document.body.appendChild(ta);
    ta.focus();
    ta.select();
    // iOS Safari needs setSelectionRange
    ta.setSelectionRange(0, ta.value.length);
    document.execCommand('copy');
    document.body.removeChild(ta);
    toast('æŠ¥é”™ä¿¡æ¯å·²å¤åˆ¶', 'info');
  } catch (e) {
    toast('å¤åˆ¶å¤±è´¥ï¼Œè¯·é•¿æŒ‰æ‰‹åŠ¨å¤åˆ¶', 'err');
  }
}

// ========== Init ==========
loadSettingsUI();
renderTasks();
refreshQueue();
</script>
</body>
</html>
